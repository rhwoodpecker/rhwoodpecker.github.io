<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="renhao blog" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="个人博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:locale">
<meta property="article:author" content="Ren Hao">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/"/>





  <title>个人博客</title>
  














<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/18/setTimeout-%E5%AE%9E%E7%8E%B0-setInterval/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/18/setTimeout-%E5%AE%9E%E7%8E%B0-setInterval/" itemprop="url">setTimeout 实现 setInterval</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-18T20:04:52+08:00">
                2020-12-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="为什么要用setTimeout实现setInterval"><a href="#为什么要用setTimeout实现setInterval" class="headerlink" title="为什么要用setTimeout实现setInterval"></a>为什么要用setTimeout实现setInterval</h3><p><strong>setInterval 缺点</strong></p>
<ul>
<li>使用 <code>setInterval</code> 时，某些间隔会被跳过；即使 <code>setInterval</code> 调用的方法报错了，他仍然会继续执行。</li>
<li>无视网络延迟，可能多个定时器会连续执行；</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p> 每个 <code>setTimeout</code> 产生的任务会直接 <code>push</code> 到<strong>任务队列</strong>中；而 <code>setInterval</code> 在每次把任务 <code>push</code> 到任务队列<strong>前</strong>，都要进行一下判断(看上次的任务是否仍在队列中)。</p>
<p>因而我们一般用 <code>setTimeout</code> 模拟 <code>setInterval</code>，来规避掉上面的缺点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; fn 执行的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; delay 延时</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">boolean</span>&#125; [immediate=false] 是否立即执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">*</span>&#125; </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mySetInterVal</span> = (<span class="params">fn, delay, immediate = <span class="literal">false</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> time = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">       time =  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">           <span class="title function_">fn</span>()</span><br><span class="line">           <span class="title function_">run</span>();</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(immediate) <span class="title function_">fn</span>()</span><br><span class="line">    <span class="title function_">run</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">clear</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(time)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> d = +<span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> t = <span class="title function_">mySetInterVal</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(+<span class="keyword">new</span> <span class="title class_">Date</span>() - d), <span class="number">1000</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    t.<span class="title function_">clear</span>()</span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行结果</p>
</blockquote>
<img width="538" alt="image" src="https://user-images.githubusercontent.com/22131908/157462397-d87097a3-abb4-41d4-9b55-1623fa38b2cd.png">


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/20/%E5%AE%9E%E7%8E%B0-add-1-2-3-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/20/%E5%AE%9E%E7%8E%B0-add-1-2-3-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/" itemprop="url">实现 add(1)(2)(3) 函数柯里化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-11-20T17:12:57+08:00">
                2020-11-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="要求实现一个函数，满足以下用例"><a href="#要求实现一个函数，满足以下用例" class="headerlink" title="要求实现一个函数，满足以下用例"></a>要求实现一个函数，满足以下用例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">add</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)；  <span class="comment">// 6</span></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>);   <span class="comment">// 6</span></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>);   <span class="comment">// 6</span></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);   <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>实现</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 柯里化函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">curry</span> = (<span class="params">fn, ...args</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// fn.length 获取函数参数的长度</span></span><br><span class="line">    <span class="comment">// 如果参数大于等于函数的参数，则直接调用，否则递归</span></span><br><span class="line">    <span class="keyword">return</span> args.<span class="property">length</span> &gt;= fn.<span class="property">length</span> </span><br><span class="line">            ? <span class="title function_">fn</span>(...args) </span><br><span class="line">                : <span class="function">(<span class="params">..._args</span>) =&gt;</span> <span class="title function_">curry</span>(fn, ...args, ..._args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add1</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = <span class="title function_">curry</span>(add1)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>)(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>,<span class="number">2</span>)(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>测试结果</p>
</blockquote>
<img width="435" alt="image" src="https://user-images.githubusercontent.com/22131908/157573270-50d34c03-59bd-4a43-a5c6-c49083fda3ff.png">


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/10/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/10/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B/" itemprop="url">发布订阅模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-10T19:31:46+08:00">
                2020-09-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventEmitter</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">handlers</span> = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加监听</span></span><br><span class="line">    <span class="title function_">on</span>(<span class="params">event, callback</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">handlers</span>[event]) <span class="variable language_">this</span>.<span class="property">handlers</span>[event] = [];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">handlers</span>[event].<span class="title function_">push</span>(callback);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除监听</span></span><br><span class="line">    <span class="title function_">off</span>(<span class="params">event, callback</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> callbacks = <span class="variable language_">this</span>.<span class="property">handlers</span>[event];</span><br><span class="line">        <span class="keyword">const</span> index = callbacks.<span class="title function_">indexOf</span>(callback);</span><br><span class="line">        <span class="keyword">if</span>(index !== -<span class="number">1</span>) callbacks.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 派发事件</span></span><br><span class="line">    <span class="title function_">emit</span>(<span class="params">event, ...args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">handlers</span>[event]) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">handlers</span>[event].<span class="title function_">forEach</span>(<span class="function"><span class="params">callback</span> =&gt;</span> <span class="title function_">callback</span>(...args));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监听一次</span></span><br><span class="line">    <span class="title function_">once</span>(<span class="params">event, callback</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">wrapper</span> = (<span class="params">...args</span>) =&gt; &#123;</span><br><span class="line">            <span class="title function_">callback</span>(...args);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">off</span>(event, callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">on</span>(event, wrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> event1 = <span class="keyword">new</span> <span class="title class_">EventEmitter</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleMessage</span> = arg =&gt;&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;message:&#x27;</span>,arg)</span><br><span class="line">&#125;</span><br><span class="line">event1.<span class="title function_">on</span>(<span class="string">&#x27;message&#x27;</span>, handleMessage)</span><br><span class="line"></span><br><span class="line">event1.<span class="title function_">emit</span>(<span class="string">&#x27;message&#x27;</span>, &#123;<span class="attr">text</span>: <span class="string">&#x27;hello&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// message: &#123; text: &#x27;hello&#x27; &#125;   </span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/08/20/React-Fiber-%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/20/React-Fiber-%E6%9E%B6%E6%9E%84/" itemprop="url">React Fiber 架构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-20T16:03:37+08:00">
                2020-08-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、Fiber-架构诞生"><a href="#一、Fiber-架构诞生" class="headerlink" title="一、Fiber 架构诞生"></a>一、Fiber 架构诞生</h2><ul>
<li>当项目变得庞大、组件数量繁多、遇到大计算量的操作或者设备性能不足使得页面掉帧，导致卡顿。</li>
</ul>
<h3 id="React-渲染页面的两个阶段"><a href="#React-渲染页面的两个阶段" class="headerlink" title="React 渲染页面的两个阶段"></a>React 渲染页面的两个阶段</h3><ul>
<li>调度阶段（<code>reconciliation</code>）：在这个阶段 <code>React</code> 会更新数据生成新的 <code>Virtual DOM</code>，然后通过<strong>Diff</strong>算法，快速找出需要更新的元素，放到更新队列中去，得到新的更新队列。</li>
<li>渲染阶段（<code>commit</code>）：这个阶段 <code>React</code> 会遍历更新队列，将其所有的变更一次性更新到 <code>DOM</code> 上。</li>
</ul>
<h3 id="React-15-架构"><a href="#React-15-架构" class="headerlink" title="React 15 架构"></a>React 15 架构</h3><p><strong>React15架构可以分为两层</strong>：</p>
<ul>
<li><strong>Reconciler</strong>（协调器）—— 负责找出变化的组件；</li>
<li><strong>Renderer</strong>（渲染器）—— 负责将变化的组件渲染到页面上；</li>
</ul>
<p>  在React15及以前，<code>Reconciler</code> 采用递归的方式创建<strong>虚拟DOM</strong>，递归过程是不能中断的。如果组件树的层级很深，递归会占用线程很多时间，递归更新时间超过了 <code>16ms</code>，用户交互就会卡顿。<br>  为了解决这个问题，<code>React16</code> 将递归的无法中断的更新重构为异步的可中断更新，由于曾经用于递归的<strong>虚拟DOM</strong>数据结构已经无法满足需要。于是，全新的 <code>Fiber</code> 架构应运而生。</p>
<h3 id="React-16-架构"><a href="#React-16-架构" class="headerlink" title="React 16 架构"></a>React 16 架构</h3><p>为了解决同步更新长时间占用线程导致页面卡顿的问题，也为了探索运行时优化的更多可能，React开始重构并一直持续至今。重构的目标是实现 <code>Concurrent Mode</code>（<strong>并发模式</strong>）。</p>
<p>从 <code>v15</code> 到 <code>v16</code>，React团队花了两年时间将源码架构中的 <code>Stack Reconciler</code> 重构为 <code>Fiber Reconciler</code>。<br>React16架构可以分为三层：</p>
<ul>
<li><strong>Scheduler</strong>（调度器）—— 调度任务的优先级，高优任务优先进入 <code>Reconciler</code>；</li>
<li><strong>Reconciler</strong>（协调器）—— 负责找出变化的组件：更新工作从递归变成了可以中断的循环过程。<code>Reconciler</code> 内部采用了 <code>Fiber</code> 的架构；</li>
<li><strong>Renderer</strong>（渲染器）—— 负责将变化的组件渲染到页面上。</li>
</ul>
<h3 id="React-17-优化"><a href="#React-17-优化" class="headerlink" title="React 17 优化"></a>React 17 优化</h3><p><code>React16</code>的 <code>expirationTimes</code> 模型只能区分是否 <code>&gt;=expirationTimes</code> 决定节点是否更新。<code>React17</code> 的 <code>lanes</code> 模型可以选定一个更新区间，并且动态的向区间中增减优先级，可以处理更细粒度的更新。</p>
<blockquote>
<p>Lane用<strong>二进制位</strong>表示任务的优先级，方便优先级的计算（位运算），不同优先级占用不同位置的“赛道”，而且存在批的概念，优先级越低，“赛道”越多。高优先级打断低优先级，新建的任务需要赋予什么优先级等问题都是Lane所要解决的问题。\</p>
</blockquote>
<p><strong>Concurrent Mode的目的是实现一套可中断&#x2F;恢复的更新机制。其由两部分组成：</strong></p>
<ul>
<li>一套协程架构：<code>Fiber Reconciler</code></li>
<li>基于协程架构的启发式更新算法：控制协程架构工作方式的算法</li>
</ul>
<h2 id="二、Fiber-架构"><a href="#二、Fiber-架构" class="headerlink" title="二、Fiber 架构"></a>二、Fiber 架构</h2><p><code>Fiber</code> 的英文含义是“纤维”，它是比线程（<code>Thread</code>）更细的线，比线程（<code>Thread</code>）控制得更精密的执行模型。在广义计算机科学概念中，Fiber 又是一种协作的（<code>Cooperative</code>）编程模型（<strong>协程</strong>），帮助开发者用一种<strong>【既模块化又协作化】</strong>的方式来编排代码。</p>
<p>在 <code>React</code> 中，<code>Fiber</code> 就是 <code>React 16</code> 实现的一套新的更新机制，让 <code>React</code> 的<strong>更新过程变得可控</strong>，避免了之前采用递归需要一气呵成影响性能的做法</p>
<h3 id="React-Fiber-时间分片"><a href="#React-Fiber-时间分片" class="headerlink" title="React Fiber 时间分片"></a>React Fiber 时间分片</h3><p>把一个<strong>耗时长的任务分成很多小片</strong>，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都<strong>给其他任务一个执行的机会</strong>，这样唯一的线程就不会被独占，其他任务依然有运行的机会。</p>
<p><code>React Fiber</code> 把更新过程<strong>碎片化</strong>，每执行完一段更新过程，就把控制权交还给 <code>React</code> 负责任务协调的模块，看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。</p>
<h3 id="React-15-的-Stack-Reconciler"><a href="#React-15-的-Stack-Reconciler" class="headerlink" title="React 15 的 Stack Reconciler"></a>React 15 的 Stack Reconciler</h3><p>基于<strong>栈</strong>的 <code>Reconciler</code>，浏览器引擎会从执行栈的顶端开始执行，执行完毕就弹出当前执行上下文，开始执行下一个函数，<strong>直到执行栈被清空才会停止</strong>。然后将执行权交还给浏览器。由于 React 将页面视图视作一个个函数执行的结果。每一个页面往往由多个视图组成，这就意味着多个函数的调用。</p>
<p>如果一个页面足够复杂，形成的函数调用栈就会很深。每一次更新，执行栈需要一次性执行完成，中途不能干其他的事儿，只能”<strong>一心一意</strong>“。结合前面提到的浏览器刷新率，JS 一直执行，浏览器得不到控制权，就不能及时开始下一帧的绘制。如果这个时间超过<br> <code>16ms</code>，当页面有动画效果需求时，动画因为浏览器<strong>不能及时绘制下一帧</strong>，这时动画就会出现卡顿。不仅如此，因为事件响应代码是在每一帧开始的时候执行，如果不能及时绘制下一帧，事件响应也会延迟。</p>
<h3 id="React-16-的-Fiber-Reconciler"><a href="#React-16-的-Fiber-Reconciler" class="headerlink" title="React 16 的 Fiber Reconciler"></a>React 16 的 Fiber Reconciler</h3><p><strong>链表结构</strong><br>在 <code>React Fiber</code> 中用<strong>链表</strong>遍历的方式替代了 <code>React 16</code> 之前的栈递归方案。在 <code>React 16</code> 中使用了大量的<strong>链表</strong>。</p>
<blockquote>
<p>使用多向链表的形式替代了原来的树结构</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;A&quot;</span>&gt;</span><br><span class="line">  <span class="variable constant_">A1</span></span><br><span class="line">  &lt;div id=<span class="string">&quot;B1&quot;</span>&gt;</span><br><span class="line">    <span class="variable constant_">B1</span></span><br><span class="line">    &lt;div id=<span class="string">&quot;C1&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;B2&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    B2</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/22131908/157614057-0c85af9d-ad97-4090-8fe0-ee031c5c2997.png" alt="image"></p>
<blockquote>
<p>副作用单链表</p>
</blockquote>
<p><img src="https://user-images.githubusercontent.com/22131908/157614111-be7bb520-dd8f-4621-951e-7875961f6a48.png" alt="image"></p>
<blockquote>
<p>状态更新单链表</p>
</blockquote>
<p><img src="https://user-images.githubusercontent.com/22131908/157614149-214aa1a1-7ceb-4d30-bead-b5314c90c634.png" alt="image"></p>
<blockquote>
<p>延伸：链表是一种简单高效的数据结构，它在当前节点中保存着指向下一个节点的指针；遍历的时候，通过操作指针找到下一个元素。</p>
</blockquote>
<p><img src="https://user-images.githubusercontent.com/22131908/157614271-904633c8-1b10-4f4b-9c5f-12c53b1233a6.png" alt="image"></p>
<p>链表相比顺序结构数据格式的<strong>好处</strong>就是：</p>
<ol>
<li>操作更高效，比如顺序调整、删除，只需要改变节点的指针指向就好了。</li>
<li>不仅可以根据当前节点找到下一个节点，在多向链表中，还可以找到他的父节点或者兄弟节点。</li>
</ol>
<p>但链表也不是完美的，<strong>缺点</strong>就是：</p>
<ol>
<li>比顺序结构数据更占用空间，因为每个节点对象还保存有指向下一个对象的指针。</li>
<li>不能自由读取，必须找到他的上一个节点。</li>
</ol>
<p>React 用<strong>空间换时间</strong>，更高效的操作可以方便根据优先级进行操作。同时<strong>可以根据当前节点找到其他节点，在下面提到的挂起和恢复过程中起到了关键作用</strong>。</p>
<h2 id="三、React-Fiber-如何实现更新过程可控"><a href="#三、React-Fiber-如何实现更新过程可控" class="headerlink" title="三、React Fiber 如何实现更新过程可控"></a>三、React Fiber 如何实现更新过程可控</h2><p>更新过程的可控主要体现在下面几个方面：</p>
<ul>
<li>任务拆分</li>
<li>任务挂起、恢复、终止</li>
<li>任务具备优先级</li>
</ul>
<h3 id="任务拆分"><a href="#任务拆分" class="headerlink" title="任务拆分"></a>任务拆分</h3><p>在 <code>React Fiber</code> 机制中，它采用”化整为零”的思想，将调和阶段（Reconciler）递归遍历 VDOM 这个大任务分成若干小任务，每个任务只负责一个节点的处理。</p>
<h3 id="任务挂起、恢复、终止"><a href="#任务挂起、恢复、终止" class="headerlink" title="任务挂起、恢复、终止"></a>任务挂起、恢复、终止</h3><blockquote>
<p>workInProgress tree</p>
</blockquote>
<p><code>workInProgress</code> 代表<strong>当前正在执行更新的 <code>Fiber</code> 树</strong>。在 <code>render</code> 或者 <code>setState</code> 后，会构建一颗 <code>Fiber</code> 树，也就是 <code>workInProgress tree</code>，这棵树在构建每一个节点的时候会<strong>收集当前节点的副作用</strong>，整棵树构建完成后，会形成一条完整的<strong>副作用链</strong>。</p>
<blockquote>
<p>currentFiber tree</p>
</blockquote>
<p><code>currentFiber</code> 表示<strong>上次渲染构建的 <code>Filber</code> 树</strong>。**在每一次更新完成后 <code>workInProgress</code> 会赋值给 <code>currentFiber</code> **。在新一轮更新时 <code>workInProgress tree</code> 再重新构建，新 <code>workInProgress</code> 的节点通过 <code>alternate</code> 属性和 <code>currentFiber</code> 的节点建立联系。</p>
<p>在新 <code>workInProgress tree</code> 的创建过程中，会同 <code>currentFiber</code> 的对应节点进行 <code>Diff</code> 比较，收集副作用。同时也会<strong>复用</strong>和 <code>currentFiber</code> 对应的节点对象，减少新创建对象带来的开销。也就是说<strong>无论是创建还是更新、挂起、恢复以及终止操作都是发生在 <code>workInProgress tree</code> 创建过程中的</strong>。<code>workInProgress tree</code> 构建过程其实就是循环的执行任务和创建下一个任务。</p>
<h4 id="挂起"><a href="#挂起" class="headerlink" title="挂起"></a>挂起</h4><p>当第一个小任务完成后，先判断这一帧是否还有<strong>空闲时间</strong>，没有就挂起下一个任务的执行，<strong>记住</strong>当前挂起的节点，让出控制权给浏览器执行更高优先级的任务。</p>
<h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><p>在浏览器渲染完一帧后，判断当前帧是否有<strong>剩余时间</strong>，如果有就恢复执行之前挂起的任务。如果没有任务需要处理，代表调和阶段完成，可以开始进入渲染阶段。</p>
<ol>
<li>如何判断一帧是否有空闲时间的呢？</li>
</ol>
<p>使用前面提到的 <code>RIC (RequestIdleCallback)</code> 浏览器原生 <code>API</code>，<code>React</code> 源码中为了兼容低版本的浏览器，对该方法进行了 <code>Polyfill</code>。</p>
<ol start="2">
<li>恢复执行的时候又是如何知道下一个任务是什么呢？</li>
</ol>
<p>答案是在前面提到的<strong>链表</strong>。在 <code>React Fiber</code> 中每个任务其实就是在处理一个 <code>FiberNode</code> 对象，然后又生成下一个任务需要处理的 <code>FiberNode</code>。</p>
<h4 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h4><p>其实并不是每次更新都会走到提交阶段。当在调和过程中触发了新的更新，在执行下一个任务的时候，判断<strong>是否有优先级更高的执行任务</strong>，如果有就终止原来将要执行的任务，开始新的 <code>workInProgressFiber</code> 树构建过程，开始新的更新流程。这样可以避免重复更新操作。这也是<strong>在 <code>React 16</code> 以后生命周期函数 <code>componentWillMount</code> 有可能会执行多次</strong>的原因。<br><img src="https://user-images.githubusercontent.com/22131908/157621232-0dad5503-f967-474f-b89d-b469a86bb252.png" alt="image"></p>
<h3 id="任务具备优先级"><a href="#任务具备优先级" class="headerlink" title="任务具备优先级"></a>任务具备优先级</h3><p><code>React Fiber</code> 除了通过挂起，恢复和终止来控制更新外，还给每个任务分配了优先级。具体点就是在创建或者更新 <code>FiberNode</code> 的时候，通过算法给每个任务分配一个到期时间（<code>expirationTime</code>）。在每个任务执行的时候除了判断剩余时间，如果当前处理节点已经过期，那么无论现在是否有空闲时间都必须执行该任务。<strong>过期时间的大小还代表着任务的优先级</strong>。</p>
<p><strong>任务在执行过程中顺便收集了每个 <code>FiberNode</code> 的副作用</strong>，将有副作用的节点通过 <code>firstEffect</code>、<code>lastEffect</code>、<code>nextEffect</code> 形成一条副作用单链表 <code>A1(TEXT)-B1(TEXT)-C1(TEXT)-C1-C2(TEXT)-C2-B1-B2(TEXT)-B2-A</code>。</p>
<p>其实<strong>最终都是为了收集到这条副作用链表，有了它，在接下来的渲染阶段就通过遍历副作用链完成 <code>DOM</code> 更新</strong>。这里需要注意，更新真实 <code>DOM</code> 的这个动作是<strong>一气呵成</strong>的，不能中断，不然会造成视觉上的不连贯（<code>commit</code>）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;A1&quot;</span>&gt;</span><br><span class="line">  <span class="variable constant_">A1</span></span><br><span class="line">  &lt;div id=<span class="string">&quot;B1&quot;</span>&gt;</span><br><span class="line">    <span class="variable constant_">B1</span></span><br><span class="line">    &lt;div id=<span class="string">&quot;C1&quot;</span>&gt;<span class="variable constant_">C1</span>&lt;/div&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;C2&quot;</span>&gt;</span>C2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;B2&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    B2</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/22131908/157621660-db4cf254-01f0-4584-b0e9-05887940fa0c.png" alt="image"></p>
<h2 id="四、Fiber结构长什么样"><a href="#四、Fiber结构长什么样" class="headerlink" title="四、Fiber结构长什么样"></a>四、Fiber结构长什么样</h2><p>基于时间分片的增量更新需要<strong>更多的上下文信息</strong>，之前的 <code>vDOM tree</code> 显然难以满足，所以扩展出了 <code>fiber tree</code>（即 <code>Fiber</code>上下文的 <code>vDOM tree</code> ），更新过程就是根据输入数据以及现有的 <code>fiber tree</code> 构造出新的 <code>fiber tree</code> （ <code>workInProgress tree</code> ）。</p>
<p><code>FiberNode</code> 上的属性有很多，根据笔者的理解，以下这么几个属性是值得关注的：<code>return</code>、<code>child</code>、<code>sibling</code>（主要负责 <code>fiber</code> 链表的链接）；<code>stateNode</code>；<code>effectTag</code>；<code>expirationTime</code>；<code>alternate</code>；<code>nextEffect</code>。各属性介绍参看下面的 <code>class FiberNode</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FiberNode</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">tag, pendingProps, key, mode</span>) &#123;</span><br><span class="line">    <span class="comment">// 实例属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tag</span> = tag; <span class="comment">// 标记不同组件类型，如函数组件、类组件、文本、原生组件...</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = key; <span class="comment">// react 元素上的 key 就是 jsx 上写的那个 key ，也就是最终 ReactElement 上的</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">elementType</span> = <span class="literal">null</span>; <span class="comment">// createElement的第一个参数，ReactElement 上的 type</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">type</span> = <span class="literal">null</span>; <span class="comment">// 表示fiber的真实类型 ，elementType 基本一样，在使用了懒加载之类的功能时可能会不一样</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stateNode</span> = <span class="literal">null</span>; <span class="comment">// 实例对象，比如 class 组件 new 完后就挂载在这个属性上面，如果是RootFiber，那么它上面挂的是 FiberRoot,如果是原生节点就是 dom 对象</span></span><br><span class="line">    <span class="comment">// fiber</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">return</span> = <span class="literal">null</span>; <span class="comment">// 父节点，指向上一个 fiber</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">child</span> = <span class="literal">null</span>; <span class="comment">// 子节点，指向自身下面的第一个 fiber</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sibling</span> = <span class="literal">null</span>; <span class="comment">// 兄弟组件, 指向一个兄弟节点</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">index</span> = <span class="number">0</span>; <span class="comment">//  一般如果没有兄弟节点的话是0 当某个父节点下的子节点是数组类型的时候会给每个子节点一个 index，index 和 key 要一起做 diff</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ref</span> = <span class="literal">null</span>; <span class="comment">// reactElement 上的 ref 属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pendingProps</span> = pendingProps; <span class="comment">// 新的 props</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">memoizedProps</span> = <span class="literal">null</span>; <span class="comment">// 旧的 props</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">updateQueue</span> = <span class="literal">null</span>; <span class="comment">// fiber 上的更新队列执行一次 setState 就会往这个属性上挂一个新的更新, 每条更新最终会形成一个链表结构，最后做批量更新</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">memoizedState</span> = <span class="literal">null</span>; <span class="comment">// 对应  memoizedProps，上次渲染的 state，相当于当前的 state，理解成 prev 和 next 的关系</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">mode</span> = mode; <span class="comment">// 表示当前组件下的子组件的渲染方式</span></span><br><span class="line">    <span class="comment">// effects</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">effectTag</span> = <span class="title class_">NoEffect</span>; <span class="comment">// 表示当前 fiber 要进行何种更新（更新、删除等）</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">nextEffect</span> = <span class="literal">null</span>; <span class="comment">// 指向下个需要更新的fiber</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">firstEffect</span> = <span class="literal">null</span>; <span class="comment">// 指向所有子节点里，需要更新的 fiber 里的第一个</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lastEffect</span> = <span class="literal">null</span>; <span class="comment">// 指向所有子节点中需要更新的 fiber 的最后一个</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">expirationTime</span> = <span class="title class_">NoWork</span>; <span class="comment">// 过期时间，代表任务在未来的哪个时间点应该被完成</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">childExpirationTime</span> = <span class="title class_">NoWork</span>; <span class="comment">// child 过期时间</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">alternate</span> = <span class="literal">null</span>; <span class="comment">// current 树和 workInprogress 树之间的相互引用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/22131908/157622436-bb9c2801-e5e6-4086-82e3-828a96128fe1.png" alt="image"></p>
<blockquote>
<p>简单模拟生成以及遍历整个fiber 树过程</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化的fiber 节点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FiberNode</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">child</span> = <span class="literal">null</span>; <span class="comment">// 子节点</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">return</span> = <span class="literal">null</span>; <span class="comment">// 父节点</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sibling</span> = <span class="literal">null</span>; <span class="comment">// 兄弟节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟的dom树结构</span></span><br><span class="line"><span class="keyword">const</span> domTree = [&#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;div#A&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [&#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;text(A1)&#x27;</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;div#B1&#x27;</span>,</span><br><span class="line">        <span class="attr">children</span>: [&#123;</span><br><span class="line">            <span class="attr">value</span>: <span class="string">&#x27;text(B1)&#x27;</span></span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            <span class="attr">value</span>: <span class="string">&#x27;div#C1&#x27;</span>,</span><br><span class="line">            <span class="attr">children</span>: [&#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="string">&#x27;text(C1)&#x27;</span></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            <span class="attr">value</span>: <span class="string">&#x27;div#C2&#x27;</span>,</span><br><span class="line">            <span class="attr">children</span>: [&#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="string">&#x27;text(C2)&#x27;</span></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;div#B2&#x27;</span>,</span><br><span class="line">        <span class="attr">children</span>: [&#123;</span><br><span class="line">            <span class="attr">value</span>: <span class="string">&#x27;text(B2)&#x27;</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成fiber树</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateFiberTree</span>(<span class="params">domTree</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> headerNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> curNode = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    domTree.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="title class_">FiberNode</span>(item.<span class="property">value</span>);</span><br><span class="line">        <span class="keyword">if</span>(!headerNode) &#123;</span><br><span class="line">            headerNode = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curNode.<span class="property">sibling</span> = node;</span><br><span class="line">            curNode = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">performChildren</span> = (<span class="params">returnNode, children</span>) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> curChildNode = <span class="literal">null</span></span><br><span class="line">            children.<span class="title function_">forEach</span>(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> childNode = <span class="keyword">new</span> <span class="title class_">FiberNode</span>(child.<span class="property">value</span>);</span><br><span class="line">                childNode.<span class="property">return</span> = returnNode;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (!curChildNode) &#123;</span><br><span class="line">                    returnNode.<span class="property">child</span> = childNode</span><br><span class="line">                    curChildNode = childNode;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    curChildNode.<span class="property">sibling</span> = childNode;</span><br><span class="line">                    curChildNode = childNode;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(child.<span class="property">children</span>) <span class="title function_">performChildren</span>(childNode, child.<span class="property">children</span>);</span><br><span class="line">            &#125;) </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(item.<span class="property">children</span>) <span class="title function_">performChildren</span>(node, item.<span class="property">children</span>);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> headerNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fiberTree = <span class="title function_">generateFiberTree</span>(domTree);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次遍历节点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">performUnitWork</span>(<span class="params">currentFiber</span>) &#123;</span><br><span class="line">    <span class="comment">// 有儿子就返回儿子</span></span><br><span class="line">    <span class="keyword">if</span> (currentFiber.<span class="property">child</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> currentFiber.<span class="property">child</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有儿子，则找弟弟</span></span><br><span class="line">    <span class="keyword">while</span>(currentFiber) &#123;</span><br><span class="line">        <span class="comment">// completeUnitWork(currentFiber);//将自己的副作用挂到父节点去</span></span><br><span class="line">        <span class="keyword">if</span>(currentFiber.<span class="property">sibling</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> currentFiber.<span class="property">sibling</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有弟弟就返回父节点</span></span><br><span class="line">            currentFiber = currentFiber.<span class="property">return</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 保存当前的fiber节点，下次终端可继续执行</span></span><br><span class="line"><span class="keyword">let</span> node = fiberTree</span><br><span class="line"><span class="comment">// 当前是是否有足够时间执行，这里为了方便，直接遍历</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">value</span>)</span><br><span class="line">    node = <span class="title function_">performUnitWork</span>(node)</span><br><span class="line">    <span class="keyword">if</span>(!node) <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行结果对比</p>
</blockquote>
<p><img src="https://user-images.githubusercontent.com/22131908/157636984-c4d8c93c-b92f-4c39-a232-a43bc09e11ca.png" alt="image"></p>
<blockquote>
<p>分析 </p>
</blockquote>
<p><img src="https://user-images.githubusercontent.com/22131908/157636890-18bf3b72-ab12-4380-b999-b40f43e2c750.png" alt="未命名绘图 drawio"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/08/09/react-hooks%E4%B8%8Eclass%E7%BB%84%E4%BB%B6%E5%AF%B9%E6%AF%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/09/react-hooks%E4%B8%8Eclass%E7%BB%84%E4%BB%B6%E5%AF%B9%E6%AF%94/" itemprop="url">react hooks与class组件对比</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-09T13:27:18+08:00">
                2020-08-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1、react-hooks解决的问题"><a href="#1、react-hooks解决的问题" class="headerlink" title="1、react-hooks解决的问题"></a>1、react-hooks解决的问题</h2><ol>
<li>函数组件中不能拥有自己的状态（state）。在hooks之前函数组件是无状态的，都是通过props来获取父组件的状态，但是hooks提供了useState来维护函数组件内部的状态。</li>
<li>函数组件中不能监听组件的生命周期。useEffect聚合了多个生命周期函数。</li>
<li>class组件中生命周期较为复杂（在15版本到16版本的变化大）。</li>
<li>class组件逻辑难以复用（HOC，render props）。</li>
</ol>
<h2 id="2、hooks对比class的好处"><a href="#2、hooks对比class的好处" class="headerlink" title="2、hooks对比class的好处"></a>2、hooks对比class的好处</h2><h4 id="1、写法更加的简洁"><a href="#1、写法更加的简洁" class="headerlink" title="1、写法更加的简洁"></a>1、写法更加的简洁</h4><p>我们以最简单的计数器为例：</p>
<blockquote>
<p>class组件</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleOfClass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; count &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">count</span>: count+<span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; count &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>you click &#123; count &#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>hooks</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ExampleOfHooks</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="title function_">setCount</span>(count + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>you click &#123; count &#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到使用 <code>hooks</code> 的代码相比 <code>class</code> 组件代码更加的简洁、清晰。</p>
<h4 id="2、业务代码更加聚合"><a href="#2、业务代码更加聚合" class="headerlink" title="2、业务代码更加聚合"></a>2、业务代码更加聚合</h4><p>使用 <code>class</code> 组件经常会出现一个功能出现在两个生命周期函数内的情况，这样分开写有时候可能会忘记。比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于添加定时器和清除定时器是在两个不同的生命周期函数，中间可能会有很多其他的业务代码，所以可能会忘记清除定时器，如果在组件卸载时没有添加清楚定时器的函数就可能会造成内存泄漏、网络一直请求等问题。</p>
<p>但是使用 <code>hooks</code> 可以让代码更加的集中，方便我们管理，也不容易忘记：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, [<span class="comment">//...])</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3、逻辑复用方便"><a href="#3、逻辑复用方便" class="headerlink" title="3、逻辑复用方便"></a>3、逻辑复用方便</h4><p>class组件的逻辑复用通常用 <code>render props</code> 以及 <code>HOC</code> 两种方式。 <code>react hooks</code> 提供了自定义 <code>hooks</code> 来复用逻辑。</p>
<p>下面以获取鼠标在页面的位置的逻辑复用为例：</p>
<blockquote>
<p>class组件render props方式复用</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MousePosition</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">y</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleMouseMove = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; clientX, clientY &#125; = e</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">x</span>: clientX,</span><br><span class="line">      <span class="attr">y</span>: clientY</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="variable language_">this</span>.<span class="property">handleMouseMove</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="variable language_">this</span>.<span class="property">handleMouseMove</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; children &#125; = <span class="variable language_">this</span>.<span class="property">props</span></span><br><span class="line">    <span class="keyword">const</span> &#123; x, y &#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;</span></span><br><span class="line"><span class="language-xml">          children(&#123;x, y&#125;)</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">MousePosition</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;</span></span><br><span class="line"><span class="language-xml">          (&#123;x, y&#125;) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">            return (</span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">p</span>&gt;</span>x:&#123;x&#125;, y: &#123;y&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            )</span></span><br><span class="line"><span class="language-xml">          &#125;</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">MousePosition</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Index</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>自定义hooks方式复用</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">usePosition</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [x, setX] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> [y, setY] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleMouseMove</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; clientX, clientY &#125; = e</span><br><span class="line">    <span class="title function_">setX</span>(clientX)</span><br><span class="line">    <span class="title function_">setY</span>(clientY)</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, handleMouseMove)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, handleMouseMove)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    &#123;x, y&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [position] = <span class="title function_">usePosition</span>()</span><br><span class="line">  <span class="keyword">return</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>x:&#123;position.x&#125;,y:&#123;position.y&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Index</span></span><br></pre></td></tr></table></figure>
<p>可以很明显的看出使用 <code>hooks</code> 对逻辑复用更加的方便，使用的时候逻辑也更加清晰。</p>
<h2 id="3、hooks常见的一些API使用"><a href="#3、hooks常见的一些API使用" class="headerlink" title="3、hooks常见的一些API使用"></a>3、hooks常见的一些API使用</h2><h4 id="1、useState"><a href="#1、useState" class="headerlink" title="1、useState"></a>1、useState</h4><blockquote>
<p>语法</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [value, setValue] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>这种语法方式是 <code>ES6</code> 的数组结构，数组的第一个值是声明的状态，第二个值是状态的改变函数。</p>
<blockquote>
<p>每一帧都有独立的状态</p>
</blockquote>
<p>个人理解针对每一帧独立的状态是采用了闭包的方法来实现的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [val, setVal] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">timeoutFn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 取得的值是点击按钮的状态，不是最新的状态</span></span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(val)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;val&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>setVal(val+1)&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;timeoutFn&#125;</span>&gt;</span>alertNumber<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当组件的状态或者 <code>props</code> 更新时，该函数组件会被重新调用渲染，并且每一次的渲染都是独立的都有自己独立的 <code>props</code> 以及 <code>state</code> ，不会影响其他的渲染。</p>
<h4 id="2、useEffect"><a href="#2、useEffect" class="headerlink" title="2、useEffect"></a>2、useEffect</h4><blockquote>
<p>语法</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//handler function...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// clean side effect</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, [<span class="comment">//dep...])</span></span><br></pre></td></tr></table></figure>
<p> <code>useEffect</code> 接收一个回调函数以及依赖项，当依赖项发生变化时才会执行里面的回调函数。 <code>useEffect</code> 类似于class组件 <code>didMount</code> 、 <code>didUpdate</code> 、 <code>willUnmount</code> 的生命周期函数。</p>
<blockquote>
<p>注意点</p>
</blockquote>
<ol>
<li>useEffect是异步的在组件渲染完成后才会执行</li>
<li>useEffect的回调函数只能返回一个清除副作用的处理函数或者不返回</li>
<li>如果useEffect传入的依赖项是空数组那么useEffect内部的函数只会执行一次</li>
</ol>
<h4 id="3、useMemo、useCallback"><a href="#3、useMemo、useCallback" class="headerlink" title="3、useMemo、useCallback"></a>3、useMemo、useCallback</h4><p><code>useMemo</code> 和 <code>useCallback</code> 主要用于减少组件的更新次数、优化组件性能的。</p>
<ol>
<li><code>useMemo</code> 接收一个回调函数以及依赖项，只有依赖项变化时才会重新执行回调函数。</li>
<li><code>useCallback</code> 接收一个回调函数以及依赖项，并且返回该回调函数的 <code>memorize</code> 版本，只有在依赖项重新变化时才会重新新的 <code>memorize</code> 版本。<blockquote>
<p>语法</p>
</blockquote>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoDate = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> data, [<span class="comment">//dep...])</span></span><br><span class="line"><span class="keyword">const</span> memoCb = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;<span class="comment">//...&#125;, [//dep...])</span></span><br></pre></td></tr></table></figure>
<p>在优化组件性能时针对 <code>class</code> 组件我们一般使用 <code>React.PureComponent</code> ，<code>PureComponent</code> 会在 <code>shouldUpdate</code> 进行一次钱比较，判断是否需要更新；针对函数组件我们一般使用 <code>React.memo</code>。但是在使用 <code>react hooks</code> 时由于每一次渲染更新都是独立的（生成了新的状态），即使使用了 <code>React.memo</code> ，也还是会重新渲染。</p>
<blockquote>
<p>比如下面这种场景，改变子组件的name值后由于父组件更新后每次都会生成新值（addAge函数会改变），所以子组件也会重新渲染。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [name, setName] = <span class="title function_">useState</span>(<span class="string">&#x27;cc&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> [age, setAge] = <span class="title function_">useState</span>(<span class="number">22</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">addAge</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setAge</span>(age + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>父组件<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;name&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> setName(e.target.value)&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>age: &#123;age&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>-------------------------<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Child</span> <span class="attr">addAge</span>=<span class="string">&#123;addAge&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title function_">memo</span>(<span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; addAge &#125; = props</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;child component update&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;addAge&#125;</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用useCallback优化</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [name, setName] = <span class="title function_">useState</span>(<span class="string">&#x27;cc&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> [age, setAge] = <span class="title function_">useState</span>(<span class="number">22</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> addAge = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setAge</span>(age + <span class="number">1</span>)</span><br><span class="line">  &#125;, [age])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>父组件<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;name&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> setName(e.target.value)&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>age: &#123;age&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>-------------------------<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Child</span> <span class="attr">addAge</span>=<span class="string">&#123;addAge&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title function_">memo</span>(<span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; addAge &#125; = props</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;child component update&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>子组件<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;addAge&#125;</span>&gt;</span>click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>只有 <code>useCallback</code> 的依赖性发生变化时，才会重新生成 <code>memorize</code> 函数。所以当改变 <code>name</code> 的状态是 <code>addAge</code> 不会变化。</p>
<h4 id="4、useRef"><a href="#4、useRef" class="headerlink" title="4、useRef"></a>4、useRef</h4><p><code>useRef</code> 类似于 <code>react.createRef</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> node = <span class="title function_">useRef</span>(initRef)</span><br></pre></td></tr></table></figure>
<p><code>useRef</code> 返回一个可变的 <code>ref</code> 对象，其 <code>current</code> 属性被初始化为传入的参数（<code>initRef</code>）</p>
<blockquote>
<p>作用在DOM上</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> node = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">&lt;input ref=&#123;node&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>这样可以通过 <code>node.current</code> 属性访问到该 <code>DOM</code> 元素。</p>
<p>需要注意的是 <strong>useRef创建的对象在组件的整个生命周期内保持不变</strong>，也就是说每次重新渲染函数组件时，返回的 <code>ref</code> 对象都是同一个（使用 <code>React.createRef</code> ，每次重新渲染组件都会重新创建 <code>ref</code>）。</p>
<h4 id="5、useReducer"><a href="#5、useReducer" class="headerlink" title="5、useReducer"></a>5、useReducer</h4><p><code>useReducer</code> 类似于 <code>redux</code> 中的 <code>reducer</code>。</p>
<blockquote>
<p>语法</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, initstate)</span><br></pre></td></tr></table></figure>
<p><code>useReducer</code> 传入一个计算函数和初始化 <code>state</code>，类似于 <code>redux</code>。通过返回的 <code>state</code> 我们可以访问状态，通过 <code>dispatch</code> 可以对状态作修改。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initstate = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">number</span>: state.<span class="property">number</span> + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;decrement&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">number</span>: state.<span class="property">number</span> - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, initstate);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">          Count: &#123;state.number&#125;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6、useContext"><a href="#6、useContext" class="headerlink" title="6、useContext"></a>6、useContext</h4><p>通过 <code>useContext</code> 我们可以更加方便的获取上层组件提供的 <code>context</code>。</p>
<blockquote>
<p>父组件</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; createContext, <span class="title class_">Children</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;./child&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title function_">createContext</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Parent<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">MyContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;name:</span> &#x27;<span class="attr">cc</span>&#x27;, <span class="attr">age:</span> <span class="attr">21</span>&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Child</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">MyContext.Provider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>子组件</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">MyContext</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./parent&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="title function_">useContext</span>(<span class="title class_">MyContext</span>) <span class="comment">// 获取父组件提供的context</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Child<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用步骤 </p>
</blockquote>
<ul>
<li>父组件创建并导出 <code>context：export const MyContext = createContext()</code></li>
<li>父组件使用provider和value提供值：<code>&lt;MyContext.provide value=&#123;&#123;name: 'cc', age: 22&#125;&#125; /&gt;</code></li>
<li>子组件导入父组件的 <code>context：import &#123; MyContext &#125; from &#39;./parent&#39;</code></li>
<li>获取父组件提供的值：<code>const data = useContext(MyContext)</code></li>
</ul>
<p>不过在多数情况下我们都不建议使用 <code>context</code>，因为会增加组件的耦合性。</p>
<h4 id="7、useLayoutEffect"><a href="#7、useLayoutEffect" class="headerlink" title="7、useLayoutEffect"></a>7、useLayoutEffect</h4><p><code>useEffect</code> 在全部渲染完毕后才会执行；<code>useLayoutEffect</code> 会在 浏览器 <code>layout</code>之后，<code>painting</code> 之前执行，并且会柱塞 <code>DOM</code>；可以使用它来读取 <code>DOM</code> 布局并同步触发重渲染。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">LayoutEffect</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [color, setColor] = <span class="title function_">useState</span>(<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">  <span class="title function_">useLayoutEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">alert</span>(color) <span class="comment">// 会阻塞DOM的渲染</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">alert</span>(color) <span class="comment">// 不会阻塞</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">background:</span> <span class="attr">color</span> &#125;&#125;&gt;</span>颜色<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setColor(&#x27;red&#x27;)&#125;&gt;红<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setColor(&#x27;yellow&#x27;)&#125;&gt;黄<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中 <code>useLayoutEffect</code> 会在 <code>painting</code> 之前执行，<code>useEffect</code> 在 <code>painting</code> 之后执行。</p>
<p><code>hooks</code> 让函数组件拥有了内部状态、生命周期，使用 <code>hooks</code> 让代码更加的简介，自定义 <code>hooks</code> 方便了对逻辑的复用，并且摆脱了<code>class</code> 组件的 <code>this</code> 问题；但是在使用 <code>hooks</code> 时会产生一些闭包问题，需要仔细使用。</p>
<blockquote>
<p>参考文章：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903985338400782">juejin.cn&#x2F;post&#x2F;684490…</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/07/31/React-15-%E5%92%8C-React-16-%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/31/React-15-%E5%92%8C-React-16-%E7%9A%84%E5%8C%BA%E5%88%AB/" itemprop="url">React 15 和 React 16 的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-31T20:46:30+08:00">
                2020-07-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><h2 id="react15的架构可以分为两层："><a href="#react15的架构可以分为两层：" class="headerlink" title="react15的架构可以分为两层："></a>react15的架构可以分为两层：</h2><ul>
<li><code>Reconciler</code>（协调器）— 找出需要更新的组件，以及标识出如何更新</li>
<li><code>Renderer</code>（渲染器）— 负责将变化后的组件渲染到页面上</li>
</ul>
<h2 id="react16的架构可以分为三层："><a href="#react16的架构可以分为三层：" class="headerlink" title="react16的架构可以分为三层："></a>react16的架构可以分为三层：</h2><ul>
<li><code>Scheduler</code>（调度器）— 调度任务的优先级，高级优先级的优先进入 <code>Reconciler</code> 阶段</li>
<li><code>Reconciler</code>（协调器）— 找出需要更新的组件，以及标识出如何更新</li>
<li><code>Renderer</code>（渲染器）— 负责将变化后的组件渲染到页面上</li>
</ul>
<p>浏览器的<code>16.6ms</code>机制</p>
<p>对人眼来说，正常流畅的刷新率为<code>60hz</code>，即 <code>60帧</code>，即浏览器<code>16.6ms</code>刷新一次。</p>
<p>我们知道js可以操作 <code>dom</code> 元素，所以浏览器的 <code>GUI</code> 线程和 <code>js</code> 线程是互斥的。<code>js</code> 的执行和浏览器的绘制、布局不能同时进行。所以在每 <code>16.6ms</code> 内浏览器要执行如下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JS脚本执行 ------ 浏览器样式布局 ------ 浏览器样式绘制</span><br></pre></td></tr></table></figure>

<p>如果js脚本执行时间过长，超过16.6ms，这次刷新中浏览器绘制和布局就无法执行，这就会造成人眼可识别的卡顿，发现操作时浏览器没有“实时”做出反应。如：对于用户在输入框输入内容这个行为来说，就体现为按下了键盘按键但是页面上不实时显示输入。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="react-15"><a href="#react-15" class="headerlink" title="react 15"></a>react 15</h3><p><strong>react15</strong> 的 <code>reconciler</code> 是 <code>stack-reconciler</code>。</p>
<p>即是采用递归形式工作的，是同步的，在生成虚拟 <code>dom</code> 树并 <code>diff</code> 过程中是无法中断的。</p>
<p>这样在组件层级过深时，会造成js执行时间过长，浏览器无法布局和绘制，造成丢帧。</p>
<h3 id="react-16"><a href="#react-16" class="headerlink" title="react 16"></a>react 16</h3><p><strong>react16</strong>的 <code>reconciler</code> 是 <code>fiber-reconciler</code>。</p>
<p>即采用的异步可中断更新代替react15的同步更新，react16的 <code>scheduler</code> 调度器会告诉 <code>reconciler</code> ，浏览器是否有空闲时间执行js脚本。</p>
<p>这样就不会影响浏览器的绘制和布局工作。不会丢帧。<br>在react16中，原来的虚拟 <code>DOM</code>,因其结构已不能满足异步可中断更新的需求，改而采用新的结构 <code>Fiber</code>。</p>
<p><code>虚拟dom</code> 节对应变为 <code>Fiber 节点</code>，虚拟dom树对应变为 <code>Fiber树</code>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/07/30/%E5%9B%BE%E8%A7%A3-script-%E6%A0%87%E7%AD%BE%E4%B8%AD%E7%9A%84-async-%E5%92%8C-defer-%E5%B1%9E%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/30/%E5%9B%BE%E8%A7%A3-script-%E6%A0%87%E7%AD%BE%E4%B8%AD%E7%9A%84-async-%E5%92%8C-defer-%E5%B1%9E%E6%80%A7/" itemprop="url">图解 script 标签中的 async 和 defer 属性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-30T21:10:40+08:00">
                2020-07-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在 HTML 中会遇到以下三类 script：</p>
<ul>
<li><code>&lt;script src=&#39;xxx&#39;&gt;&lt;/script&gt;</code></li>
<li><code>&lt;script src=&#39;xxx&#39; async&gt;&lt;/script&gt;</code></li>
<li><code>&lt;script src=&#39;xxx&#39; defer&gt;&lt;/script&gt;</code></li>
</ul>
<p>那么这三类 script 有什么区别呢？</p>
<h3 id="script"><a href="#script" class="headerlink" title="script"></a>script</h3><p>浏览器在解析 HTML 的时候，如果遇到一个没有任何属性的 script 标签，就会暂停解析，先发送网络请求获取该 JS 脚本的代码内容，然后让 JS 引擎执行该代码，当代码执行完毕后恢复解析。整个过程如下图所示：<br><img src="https://user-images.githubusercontent.com/22131908/156511880-6cc4f42a-225d-406c-8fad-31dc6a360690.png" alt="image"><br>可以看到，script 阻塞了浏览器对 HTML 的解析，如果获取 JS 脚本的网络请求迟迟得不到响应，或者 JS 脚本执行时间过长，都会导致白屏，用户看不到页面内容。</p>
<h3 id="async-script"><a href="#async-script" class="headerlink" title="async script"></a>async script</h3><p><code>async</code> 表示异步，例如七牛的源码中就有大量的 <code>async</code> 出现：<br><img src="https://user-images.githubusercontent.com/22131908/156512013-caef9049-da96-40c3-9b1f-ea500883f72c.png" alt="image"><br>当浏览器遇到带有 <code>async</code> 属性的 script 时，请求该脚本的网络请求是异步的，不会阻塞浏览器解析 HTML，一旦网络请求回来之后，如果此时 HTML 还没有解析完，浏览器会暂停解析，先让 JS 引擎执行代码，执行完毕后再进行解析，图示如下：<br><img src="https://user-images.githubusercontent.com/22131908/156512078-ba9bca83-12e4-4a68-a480-26f1ccfbc8ef.png" alt="image"><br>当然，如果在 JS 脚本请求回来之前，HTML 已经解析完毕了，那就啥事没有，立即执行 JS 代码，如下图所示：<br><img src="https://user-images.githubusercontent.com/22131908/156512159-a4d76bf9-e1f4-44d6-9c26-2d7e09bbb4a4.png" alt="image"><br>所以 <code>async</code> 是不可控的，因为执行时间不确定，你如果在异步 JS 脚本中获取某个 DOM 元素，有可能获取到也有可能获取不到。而且如果存在多个 <code>async</code> 的时候，它们之间的执行顺序也不确定，完全依赖于网络传输结果，谁先到执行谁。</p>
<h3 id="defer-script"><a href="#defer-script" class="headerlink" title="defer script"></a>defer script</h3><p><code>defer</code> 表示延迟，例如掘金的源码中就有大量的 <code>defe</code>r 出现：<br><img src="https://user-images.githubusercontent.com/22131908/156512240-f9f4127f-6f54-4f06-b091-7c5889c3c99e.png" alt="image"><br>当浏览器遇到带有 <code>defer</code> 属性的 script 时，获取该脚本的网络请求也是异步的，不会阻塞浏览器解析 HTML，一旦网络请求回来之后，如果此时 HTML 还没有解析完，浏览器不会暂停解析并执行 JS 代码，而是等待 HTML 解析完毕再执行 JS 代码，图示如下：<br><img src="https://user-images.githubusercontent.com/22131908/156512315-482c78e4-bfcd-488c-aad4-d907193d1637.png" alt="image"><br>如果存在多个 <code>defer script</code> 标签，浏览器（IE9及以下除外）会保证它们按照在 HTML 中出现的顺序执行，不会破坏 JS 脚本之间的依赖关系。</p>
<p>最后，根据上面的分析，不同类型 script 的执行顺序及其是否阻塞解析 HTML 总结如下：</p>
<table>
<thead>
<tr>
<th>script 标签</th>
<th>JS 执行顺序</th>
<th>是否阻塞解析 HTML</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;script&gt;</code></td>
<td>在 HTML 中的顺序</td>
<td>阻塞</td>
</tr>
<tr>
<td><code>&lt;script async&gt;</code></td>
<td>网络请求返回顺序</td>
<td>可能阻塞，也可能不阻塞</td>
</tr>
<tr>
<td><code>&lt;script defer&gt;</code></td>
<td>在 HTML 中的顺序</td>
<td>不阻塞</td>
</tr>
</tbody></table>
<blockquote>
<p>本文摘自 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6894629999215640583">图解 script 标签中的 async 和 defer 属性</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/07/04/react-setState%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/04/react-setState%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/" itemprop="url">react setState执行机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-04T20:18:22+08:00">
                2020-07-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、开发中常遇到的问题"><a href="#一、开发中常遇到的问题" class="headerlink" title="一、开发中常遇到的问题"></a>一、开发中常遇到的问题</h2><h3 id="1-setState是同步还是异步的，为什么有的时候不能立即拿到更新结果而有的时候可以"><a href="#1-setState是同步还是异步的，为什么有的时候不能立即拿到更新结果而有的时候可以" class="headerlink" title="1. setState是同步还是异步的，为什么有的时候不能立即拿到更新结果而有的时候可以?"></a>1. setState是同步还是异步的，为什么有的时候不能立即拿到更新结果而有的时候可以?</h3><h4 id="1-1-钩子函数和React合成事件中的setState"><a href="#1-1-钩子函数和React合成事件中的setState" class="headerlink" title="1.1 钩子函数和React合成事件中的setState"></a>1.1 钩子函数和React合成事件中的<code>setState</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">state = &#123;</span><br><span class="line">    <span class="attr">index</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">    <span class="attr">index</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">index</span> + <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;state&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">index</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">    <span class="attr">index</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">index</span> + <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;state&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">index</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">state, 0</span><br><span class="line">state, 0</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>调用<code>setState</code>不会立即更新</li>
<li>所有组件使用的是同一套更新机制，当所有组件<code>didmount</code>后，父组件<code>didmount</code>，然后执行更新</li>
<li>更新时会把每个组件的更新合并，每个组件只会触发一次更新的生命周期。</li>
</ul>
<h4 id="1-2-异步函数和原生事件中的setstate？"><a href="#1-2-异步函数和原生事件中的setstate？" class="headerlink" title="1.2 异步函数和原生事件中的setstate？"></a>1.2 异步函数和原生事件中的setstate？</h4><p>在<code>setTimeout</code>中调用<code>setState</code>（例子和在浏览器原生事件以及接口回调中执行效果相同）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">state = &#123;</span><br><span class="line"><span class="attr">index</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;调用setState&#x27;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            <span class="attr">index</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">index</span> + <span class="number">1</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;state&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">index</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;调用setState&#x27;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            <span class="attr">index</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">index</span> + <span class="number">1</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;state&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">index</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;componentDidUpdate&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;render&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">调用setState</span><br><span class="line">render</span><br><span class="line">componentDidUpdate</span><br><span class="line">state, <span class="number">1</span></span><br><span class="line">调用setState</span><br><span class="line">render</span><br><span class="line">componentDidUpdate</span><br><span class="line">state, <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li><code>setState</code>同步更新</li>
</ul>
<ol start="2">
<li>为什么有时连续两次setState只有一次生效？</li>
</ol>
<hr>
<p>分别执行以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">index</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">index</span> + <span class="number">1</span> &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">index</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">index</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">index</span> + <span class="number">1</span> &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">index</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">preState</span>) =&gt;</span> (&#123; <span class="attr">index</span>: preState.<span class="property">index</span> + <span class="number">1</span> &#125;), <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">index</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">preState</span> =&gt;</span> (&#123; <span class="attr">index</span>: preState.<span class="property">index</span> + <span class="number">1</span> &#125;), <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">index</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>直接传递对象的<code>setstate</code>会被合并成一次</li>
<li>使用函数传递<code>state</code>不会被合并</li>
</ul>
<h2 id="二、setState执行过程"><a href="#二、setState执行过程" class="headerlink" title="二、setState执行过程"></a>二、setState执行过程</h2><h3 id="1-流程图"><a href="#1-流程图" class="headerlink" title="1. 流程图"></a>1. 流程图</h3><hr>
<p><img src="https://user-images.githubusercontent.com/22131908/156884563-2e8215c7-9b6c-4585-88d1-2a8a1d60be29.png" alt="image"></p>
<p>说明：</p>
<ul>
<li><code>partialState</code>：<code>setState</code>传入的第一个参数，对象或函数</li>
<li><code>_pendingStateQueue</code>：当前组件等待执行更新的<code>state</code>队列</li>
<li><code>isBatchingUpdates</code>：<code>react</code>用于标识当前是否处于批量更新状态，所有组件公用</li>
<li><code>dirtyComponent</code>：当前所有处于待更新状态的组件队列</li>
<li><code>transcation</code>：<code>react</code>的事务机制，在被事务调用的方法外包装<code>n</code>个<code>waper</code>对象，并一次执行：<code>waper.init</code>、被调用方法、<code>waper.close</code></li>
<li><code>FLUSH_BATCHED_UPDATES</code>：用于执行更新的<code>waper</code>，只有一个<code>close</code>方法</li>
</ul>
<h3 id="2-执行过程"><a href="#2-执行过程" class="headerlink" title="2. 执行过程"></a>2. 执行过程</h3><hr>
<p>对照上面流程图的文字说明，大概可分为以下几步：</p>
<ol>
<li>将<code>setState</code>传入的<code>partialState</code>参数存储在当前组件实例的<code>state</code>暂存队列中。</li>
<li>判断当前<code>React</code>是否处于批量更新状态，如果是，将当前组件加入待更新的组件队列中。</li>
<li>如果未处于批量更新状态，将批量更新状态标识设置为<code>true</code>，用事务再次调用前一步方法，保证当前组件加入到了待更新组件队列中。</li>
<li>调用事务的<code>waper</code>方法，遍历待更新组件队列依次执行更新。</li>
<li>执行生命周期<code>componentWillReceiveProps</code>。</li>
<li>将组件的<code>state</code>暂存队列中的<code>state</code>进行合并，获得最终要更新的state对象，并将队列置为空。</li>
<li>执行生命周期<code>componentShouldUpdate</code>，根据返回值判断是否要继续更新。</li>
<li>执行生命周期<code>componentWillUpdate</code>。</li>
<li>执行真正的更新<code>render</code>。</li>
<li>执行生命周期<code>componentDidUpdate</code>。</li>
</ol>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><h3 id="1-钩子函数和合成事件中："><a href="#1-钩子函数和合成事件中：" class="headerlink" title="1.钩子函数和合成事件中："></a>1.钩子函数和合成事件中：</h3><hr>
<p>在<code>react</code>的生命周期和合成事件中，<code>react</code>仍然处于他的更新机制中，这时<code>isBranchUpdate</code>为<code>true</code>。</p>
<p>按照上述过程，这时无论调用多少次<code>setState</code>，都会不会执行更新，而是将要更新的state存入<code>_pendingStateQueue</code>，将要更新的组件存入<code>dirtyComponent</code>。</p>
<p>当上一次更新机制执行完毕，以生命周期为例，所有组件，即最顶层组件<code>didmount</code>后会将<code>isBranchUpdate</code>设置为<code>false</code>。这时将执行之前累积的<code>setState</code>。</p>
<h3 id="2-异步函数和原生事件中"><a href="#2-异步函数和原生事件中" class="headerlink" title="2. 异步函数和原生事件中"></a>2. 异步函数和原生事件中</h3><hr>
<p>由执行机制看，<code>setState</code>本身并不是异步的，而是如果在调用<code>setState</code>时，如果<code>react</code>正处于更新过程，当前更新会被暂存，等上一次更新执行后在执行，这个过程给人一种异步的假象。</p>
<p>在生命周期，根据JS的异步机制，会将异步函数先暂存，等所有同步代码执行完毕后在执行，这时上一次更新过程已经执行完毕，<code>isBranchUpdate</code>被设置为<code>false</code>，根据上面的流程，这时再调用<code>setState</code>即可立即执行更新，拿到更新结果。</p>
<h2 id="3-partialState合并机制"><a href="#3-partialState合并机制" class="headerlink" title="3. partialState合并机制"></a>3. <code>partialState</code>合并机制</h2><hr>
<p>我们看下流程中<code>_processPendingState</code>的代码，这个函数是用来合并<code>state</code>暂存队列的，最后返回一个合并后的<code>state</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">_processPendingState</span>: <span class="keyword">function</span> (<span class="params">props, context</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> inst = <span class="variable language_">this</span>.<span class="property">_instance</span>;</span><br><span class="line"><span class="keyword">var</span> queue = <span class="variable language_">this</span>.<span class="property">_pendingStateQueue</span>;</span><br><span class="line"><span class="keyword">var</span> replace = <span class="variable language_">this</span>.<span class="property">_pendingReplaceState</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">_pendingReplaceState</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">_pendingStateQueue</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!queue) &#123;</span><br><span class="line">    <span class="keyword">return</span> inst.<span class="property">state</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (replace &amp;&amp; queue.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> queue[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nextState = <span class="title function_">_assign</span>(&#123;&#125;, replace ? queue[<span class="number">0</span>] : inst.<span class="property">state</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = replace ? <span class="number">1</span> : <span class="number">0</span>; i &lt; queue.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> partial = queue[i];</span><br><span class="line">    <span class="title function_">_assign</span>(nextState, <span class="keyword">typeof</span> partial === <span class="string">&#x27;function&#x27;</span> ? partial.<span class="title function_">call</span>(inst, nextState, props, context) : partial);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> nextState;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>我们只需要关注下面这段代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">_assign</span>(nextState, <span class="keyword">typeof</span> partial === <span class="string">&#x27;function&#x27;</span> ? partial.<span class="title function_">call</span>(inst, nextState, props, context) : partial);</span><br></pre></td></tr></table></figure>
<p>如果传入的是对象，很明显会被合并成一次：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(</span><br><span class="line">    nextState,</span><br><span class="line">    &#123;<span class="attr">index</span>: state.<span class="property">index</span>+ <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">index</span>: state.<span class="property">index</span>+ <span class="number">1</span>&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如果传入的是函数，函数的参数<code>preState</code>是前一次合并后的结果，所以计算结果是准确的。</p>
<h3 id="4-componentDidMount调用setstate"><a href="#4-componentDidMount调用setstate" class="headerlink" title="4. componentDidMount调用setstate"></a>4. <code>componentDidMount</code>调用<code>setstate</code></h3><hr>
<blockquote>
<p>在componentDidMount()中，你 可以立即调用setState()。它将会触发一次额外的渲染，但是它将在浏览器刷新屏幕之前发生。这保证了在此情况下即使render()将会调用两次，用户也不会看到中间状态。谨慎使用这一模式，因为它常导致性能问题。在大多数情况下，你可以 在constructor()中使用赋值初始状态来代替。然而，有些情况下必须这样，比如像模态框和工具提示框。这时，你需要先测量这些DOM节点，才能渲染依赖尺寸或者位置的某些东西。</p>
</blockquote>
<p>以上是官方文档的说明，不推荐直接在<code>componentDidMount</code>直接调用<code>setState</code>，由上面的分析：<code>componentDidMount</code>本身处于一次更新中，我们又调用了一次<code>setState</code>，就会在未来再进行一次<code>render</code>，造成不必要的性能浪费，大多数情况可以设置初始值来搞定。</p>
<p>当然在<code>componentDidMount</code>我们可以调用接口，再回调中去修改<code>state</code>，这是正确的做法。</p>
<p>当<code>state</code>初始值依赖<code>dom</code>属性时，在<code>componentDidMount</code>中<code>setState</code>是无法避免的。</p>
<h3 id="5-componentWillUpdate-componentDidUpdate"><a href="#5-componentWillUpdate-componentDidUpdate" class="headerlink" title="5. componentWillUpdate componentDidUpdate"></a>5. <code>componentWillUpdate</code> <code>componentDidUpdate</code></h3><hr>
<p>这两个生命周期中不能调用<code>setState</code>。</p>
<p>由上面的流程图很容易发现，在它们里面调用<code>setState</code>会造成死循环，导致程序崩溃。</p>
<h3 id="6-推荐使用方式"><a href="#6-推荐使用方式" class="headerlink" title="6. 推荐使用方式"></a>6. 推荐使用方式</h3><p>在调用<code>setState</code>时使用函数传递<code>state</code>值，在回调函数中获取最新更新后的<code>state</code>。</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903781813993486#heading-5">文章摘自 抖音前端安全 -【React深入】setState的执行机制</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/20/%E4%B8%80%E6%AC%A1%E5%BC%84%E6%87%82Event-Loop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/20/%E4%B8%80%E6%AC%A1%E5%BC%84%E6%87%82Event-Loop/" itemprop="url">一次弄懂Event Loop</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-20T17:26:28+08:00">
                2020-06-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Event Loop</code> 即事件循环，是指浏览器或 <code>Node</code> 的一种解决 <code>javaScript</code> 单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。</p>
<h2 id="为啥要弄懂Event-Loop"><a href="#为啥要弄懂Event-Loop" class="headerlink" title="为啥要弄懂Event Loop"></a>为啥要弄懂Event Loop</h2><ul>
<li>是要增加自己技术的深度，也就是懂得 <code>JavaScript</code> 的运行机制。</li>
<li>现在在前端领域各种技术层出不穷，掌握底层原理，可以让自己以不变，应万变。</li>
<li>应对各大互联网公司的面试，懂其原理，题目任其发挥。</li>
</ul>
<h2 id="堆、栈、队列"><a href="#堆、栈、队列" class="headerlink" title="堆、栈、队列"></a>堆、栈、队列</h2><p><img src="https://user-images.githubusercontent.com/22131908/156586737-6dcc4e2b-9517-4135-b4f6-d42bdf24e4c5.png" alt="image"></p>
<h4 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h4><p><strong>堆</strong>是一种数据结构，是利用完全二叉树维护的一组数据，<strong>堆</strong>分为两种，一种为<strong>最大堆</strong>，一种为<strong>最小堆</strong>，将根节点<strong>最大</strong>的堆叫做<strong>最大堆</strong>或<strong>大根堆</strong>，根节点<strong>最小</strong>的堆叫做<strong>最小堆</strong>或<strong>小根堆</strong>。<br>堆是<strong>线性数据结构</strong>，相当于<strong>一维数组</strong>，有唯一后继。</p>
<p>如最大堆:<br><img src="https://user-images.githubusercontent.com/22131908/156587249-95dd8d06-3d8a-435d-9189-837decbdd27f.png" alt="image"></p>
<h4 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h4><p><strong>栈</strong>在计算机科学中是限定仅在<strong>表尾</strong>进行<strong>插入</strong>或<strong>删除</strong>操作的线性表。 <strong>栈</strong>是一种数据结构，它按照<strong>后进先出</strong>的原则存储数据，<strong>先进入</strong>的数据被压入<strong>栈底</strong>，最后的数据在栈顶，需要读数据的时候从<strong>栈顶</strong>开始<strong>弹出</strong>数据。<br><strong>栈</strong>是只能在某一端<strong>插入</strong>和<strong>删除</strong>的特殊线性表。<br><img src="https://user-images.githubusercontent.com/22131908/156587685-7d45bb63-5e22-4fa4-b23a-3290c0e1637a.png" alt="image"></p>
<h4 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h4><p>特殊之处在于它只允许在表的前端（<code>front</code>）进行<strong>删除</strong>操作，而在表的后端（<code>rear</code>）进行<strong>插入</strong>操作，和<strong>栈</strong>一样，队列是一种操作受限制的线性表。<br>进行<strong>插入</strong>操作的端称为<strong>队尾</strong>，进行<strong>删除</strong>操作的端称为<strong>队头</strong>。  队列中没有元素时，称为<strong>空队列</strong>。</p>
<p><strong>队列</strong>的数据元素又称为<strong>队列元素</strong>。在队列中插入一个队列元素称为<strong>入队</strong>，从<strong>队列</strong>中<strong>删除</strong>一个队列元素称为<strong>出队</strong>。因为队列只允许在一端<strong>插入</strong>，在另一端<strong>删除</strong>，所以只有<strong>最早</strong>进入<strong>队列</strong>的元素才能<strong>最先</strong>从队列中<strong>删除</strong>，故队列又称为<strong>先进先出</strong>（<code>FIFO—first in first out</code>）<br><img src="https://user-images.githubusercontent.com/22131908/156588399-0e34c25e-a518-4058-8ff2-3f685aeab1fa.png" alt="image"></p>
<h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>在<code>JavaScript</code>中，任务被分为两种，一种宏任务（<code>MacroTask</code>）也叫<code>Task</code>，一种叫微任务（<code>MicroTask</code>）。</p>
<h4 id="MacroTask（宏任务）"><a href="#MacroTask（宏任务）" class="headerlink" title="MacroTask（宏任务）"></a>MacroTask（宏任务）</h4><ul>
<li><code>script</code>全部代码、<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>（浏览器暂时不支持，只有IE10支持，具体可见<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setImmediate">MDN</a>）、<code>I/O</code>、<code>UI Rendering</code>。</li>
</ul>
<h4 id="MicroTask（微任务）"><a href="#MicroTask（微任务）" class="headerlink" title="MicroTask（微任务）"></a>MicroTask（微任务）</h4><p><code>Process.nextTick</code>（Node独有）、<code>Promise</code>、<code>Object.observe</code>(废弃)、<code>MutationObserver</code>（具体使用方式查看<a href="https://link.juejin.cn/?target=http://javascript.ruanyifeng.com/dom/mutationobserver.html">这里</a>）</p>
<h2 id="浏览器中的Event-Loop"><a href="#浏览器中的Event-Loop" class="headerlink" title="浏览器中的Event Loop"></a>浏览器中的Event Loop</h2><p><code>Javascript</code> 有一个 <code>main thread</code> 主线程和 <code>call-stack</code> 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。</p>
<h4 id="JS调用栈"><a href="#JS调用栈" class="headerlink" title="JS调用栈"></a>JS调用栈</h4><p>JS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。</p>
<h4 id="同步任务和异步任务"><a href="#同步任务和异步任务" class="headerlink" title="同步任务和异步任务"></a>同步任务和异步任务</h4><p><code>Javascript</code> 单线程任务被分为<strong>同步任务</strong>和<strong>异步任务</strong>，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。<br><img src="https://user-images.githubusercontent.com/22131908/156589367-91ccf584-db49-40cf-9beb-961409c16957.png" alt="image"><br>任务队列 <code>Task Queue</code>，即队列，是一种先进先出的一种数据结构。<br><img src="https://user-images.githubusercontent.com/22131908/156589430-ddb684fe-df78-49ce-bd16-4c47c804310b.png" alt="image"></p>
<h4 id="事件循环的进程模型"><a href="#事件循环的进程模型" class="headerlink" title="事件循环的进程模型"></a>事件循环的进程模型</h4><ul>
<li>选择当前要执行的任务队列，选择任务队列中最先进入的任务，如果任务队列为空即 <code>null</code>，则执行跳转到微任务（<code>MicroTask</code>）的执行步骤。</li>
<li>将事件循环中的任务设置为已选择任务。</li>
<li>执行任务。</li>
<li>将事件循环中当前运行任务设置为 <code>null</code>。</li>
<li>将已经运行完成的任务从任务队列中删除。</li>
<li><code>microtasks</code> 步骤：进入 <code>microtask</code> 检查点。</li>
<li>更新界面渲染。</li>
<li>返回第一步。</li>
</ul>
<h4 id="执行进入microtask检查点时，用户代理会执行以下步骤："><a href="#执行进入microtask检查点时，用户代理会执行以下步骤：" class="headerlink" title="执行进入microtask检查点时，用户代理会执行以下步骤："></a>执行进入microtask检查点时，用户代理会执行以下步骤：</h4><ul>
<li>设置 <code>microtask</code> 检查点标志为 <code>true</code>。</li>
<li>当事件循环 <code>microtask</code> 执行不为空时：选择一个最先进入的 <code>microtask</code> 队列的 <code>microtask</code> ，将事件循环的 <code>microtask</code> 设置为已选择的 <code>microtask</code>，运行 <code>microtask</code>，将已经执行完成的 <code>microtask</code> 为 <code>null</code>，移出 <code>microtask</code> 中的 <code>microtask</code>。</li>
<li>清理 <code>IndexDB</code> 事务</li>
<li>设置进入 <code>microtask</code> 检查点的标志为 <code>false</code>。</li>
</ul>
<p>上述可能不太好理解，下图是我做的一张图片:<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/18/1686078c7a2f63e5~tplv-t2oaga2asx-watermark.awebp" alt="image"><br>执行栈在执行完<strong>同步任务</strong>后，查看<strong>执行栈</strong>是否为空，如果<strong>执行栈</strong>为空，就会去检查<strong>微任务</strong>(<code>microTask</code>)队列是否为空，如果为空的话，就执行 <code>Task</code>（宏任务），否则就一次性执行完所有微任务。<br>每次单个<strong>宏任务</strong>执行完毕后，检查<strong>微任务</strong>(<code>microTask</code>)队列是否为空，如果不为空的话，会按照<strong>先入先出</strong>的规则全部执行完微任务(<code>microTask</code>)后，设置<strong>微任务</strong>(<code>microTask</code>)队列为 <code>null</code>，然后再执行<strong>宏任务</strong>，如此<strong>循环</strong>。</p>
<h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>首先我们划分几个分类：</p>
<h4 id="第一次执行："><a href="#第一次执行：" class="headerlink" title="第一次执行："></a>第一次执行：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Tasks</span>：run script、 <span class="built_in">setTimeout</span> callback</span><br><span class="line"></span><br><span class="line"><span class="title class_">Microtasks</span>：<span class="title class_">Promise</span> then	</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">JS</span> <span class="attr">stack</span>: script	</span><br><span class="line"><span class="title class_">Log</span>: script start、script end。</span><br></pre></td></tr></table></figure>
<p>执行同步代码，将宏任务（<code>Tasks</code>）和微任务(<code>Microtasks</code>)划分到各自队列中。</p>
<h4 id="第二次执行："><a href="#第二次执行：" class="headerlink" title="第二次执行："></a>第二次执行：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Tasks</span>：run script、 <span class="built_in">setTimeout</span> callback</span><br><span class="line"></span><br><span class="line"><span class="title class_">Microtasks</span>：<span class="title class_">Promise2</span> then	</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">JS</span> <span class="attr">stack</span>: <span class="title class_">Promise2</span> callback	</span><br><span class="line"><span class="title class_">Log</span>: script start、script end、promise1、promise2</span><br></pre></td></tr></table></figure>
<p>执行宏任务后，检测到微任务(<code>Microtasks</code>)队列中不为空，执行 <code>Promise1</code>，执行完成 <code>Promise1</code> 后，调用 <code>Promise2.then</code> ，放入微任务(<code>Microtasks</code>)队列中，再执行 <code>Promise2.then</code>。</p>
<h4 id="第三次执行："><a href="#第三次执行：" class="headerlink" title="第三次执行："></a>第三次执行：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Tasks</span>：<span class="built_in">setTimeout</span> callback</span><br><span class="line"></span><br><span class="line"><span class="title class_">Microtasks</span>：	</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">JS</span> <span class="attr">stack</span>: <span class="built_in">setTimeout</span> callback</span><br><span class="line"><span class="title class_">Log</span>: script start、script end、promise1、promise2、<span class="built_in">setTimeout</span></span><br></pre></td></tr></table></figure>
<p>当微任务(<code>Microtasks</code>)队列中为空时，执行宏任务（<code>Tasks</code>），执行 <code>setTimeout callback</code>，打印日志。</p>
<h4 id="第四次执行："><a href="#第四次执行：" class="headerlink" title="第四次执行："></a>第四次执行：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Tasks</span>：<span class="built_in">setTimeout</span> callback</span><br><span class="line"></span><br><span class="line"><span class="title class_">Microtasks</span>：	</span><br><span class="line"></span><br><span class="line"><span class="variable constant_">JS</span> <span class="attr">stack</span>: </span><br><span class="line"><span class="title class_">Log</span>: script start、script end、promise1、promise2、<span class="built_in">setTimeout</span></span><br></pre></td></tr></table></figure>
<p>清空 <code>Tasks</code> 队列和 <code>JS stack</code>。</p>
<p>以上执行帧动画可以查看<a href="https://link.juejin.cn/?target=https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">Tasks, microtasks, queues and schedules</a><br>或许这张图也更好理解些。<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/18/16860ae5ad02f993~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<h2 id="再举个例子"><a href="#再举个例子" class="headerlink" title="再举个例子"></a>再举个例子</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2 end&#x27;</span>) </span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">async1</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise&#x27;</span>)</span><br><span class="line">  <span class="title function_">resolve</span>()</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这里需要先理解 <code>async/await</code>。<br><code>async/await</code> 在底层转换成了 <code>promise</code> 和 <code>then</code> 回调函数。<br>也就是说，这是 <code>promise</code> 的语法糖。<br>每次我们使用 <code>await</code>, 解释器都创建一个 <code>promise</code> 对象，然后把剩下的 <code>async</code> 函数中的操作放到 <code>then</code> 回调函数中。<br><code>async/await</code> 的实现，离不开 <code>Promise</code>。从字面意思来理解，<code>async</code> 是“异步”的简写，而 <code>await</code> 是 <code>async wait</code> 的简写可以认为是等待异步方法执行完成。</p>
<h4 id="关于73以下版本和73版本的区别"><a href="#关于73以下版本和73版本的区别" class="headerlink" title="关于73以下版本和73版本的区别"></a>关于73以下版本和73版本的区别</h4><ul>
<li>在老版本版本以下，先执行 <code>promise1</code> 和 <code>promise2</code>，再执行 <code>async1</code>。</li>
<li>在73版本，先执行 <code>async1</code> 再执行 <code>promise1</code> 和 <code>promise2</code>。</li>
</ul>
<h4 id="主要原因是因为在谷歌-金丝雀-73版本中更改了规范，如下图所示："><a href="#主要原因是因为在谷歌-金丝雀-73版本中更改了规范，如下图所示：" class="headerlink" title="主要原因是因为在谷歌(金丝雀)73版本中更改了规范，如下图所示："></a>主要原因是因为在谷歌(金丝雀)73版本中更改了规范，如下图所示：</h4><p><img src="https://user-images.githubusercontent.com/22131908/156733706-04eaf1fe-73b0-48d9-9d7b-369617760f67.png" alt="image"></p>
<ul>
<li>区别在于 <code>RESOLVE(thenable)</code> 和之间的区别 <code>Promise.resolve(thenable)</code>。</li>
</ul>
<h4 id="在老版本中"><a href="#在老版本中" class="headerlink" title="在老版本中"></a>在老版本中</h4><ul>
<li>首先，传递给 <code>await</code> 的值被包裹在一个 <code>Promise</code> 中。然后，处理程序附加到这个包装的 <code>Promise</code>，以便在 <code>Promise</code> 变为 <code>fulfilled</code> 后恢复该函数，并且暂停执行异步函数，一旦 <code>promise</code> 变为 <code>fulfilled</code>，恢复异步函数的执行。</li>
<li>每个 <code>await</code> 引擎必须创建两个额外的 <code>Promise</code>（即使右侧已经是一个 <code>Promise</code>）并且它需要至少三个 <code>microtask</code> 队列 <code>ticks</code>（<code>tick</code>为系统的相对时间单位，也被称为系统的时基，来源于定时器的周期性中断（输出脉冲），一次中断表示一个<code>tick</code>，也被称做一个“时钟滴答”、时标。）。</li>
</ul>
<h4 id="引用贺老师知乎上的一个例子"><a href="#引用贺老师知乎上的一个例子" class="headerlink" title="引用贺老师知乎上的一个例子"></a>引用贺老师知乎上的一个例子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> p</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简化理解为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">RESOLVE</span>(p).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果 <code>RESOLVE(p)</code> 对于 <code>p</code> 为 <code>promise</code> 直接返回 <code>p</code> 的话，那么 <code>p</code> 的 <code>then</code> 方法就会被马上调用，其回调就立即进入 <code>job</code> 队列。</li>
<li>而如果 <code>RESOLVE(p)</code> 严格按照标准，应该是产生一个新的 <code>promise</code>，尽管该 <code>promise</code> 确定会 <code>resolve</code> 为 <code>p</code>，但这个过程本身是异步的，也就是现在进入 <code>job</code> 队列的是新 <code>promise</code> 的 <code>resolve</code>过程，所以该 <code>promise</code> 的 <code>then</code> 不会被立即调用，而要等到当前 <code>job</code> 队列执行到前述 <code>resolve</code> 过程才会被调用，然后其回调（也就是继续 <code>await</code> 之后的语句）才加入 <code>job</code> 队列，所以时序上就晚了。</li>
</ul>
<h4 id="谷歌（金丝雀）73版本中"><a href="#谷歌（金丝雀）73版本中" class="headerlink" title="谷歌（金丝雀）73版本中"></a>谷歌（金丝雀）73版本中</h4><ul>
<li>使用对 <code>PromiseResolve</code> 的调用来更改 <code>await</code> 的语义，以减少在公共 <code>awaitPromise</code> 情况下的转换次数。</li>
<li>如果传递给 <code>await</code> 的值已经是一个 <code>Promise</code>，那么这种优化避免了再次创建 <code>Promise</code> 包装器，在这种情况下，我们从最少三个 <code>microtick</code> 到只有一个 <code>microtick</code>。</li>
</ul>
<h4 id="详细过程："><a href="#详细过程：" class="headerlink" title="详细过程："></a>详细过程：</h4><h5 id="73以下版本"><a href="#73以下版本" class="headerlink" title="73以下版本"></a>73以下版本</h5><ul>
<li>首先，打印 <code>script start</code>，调用 <code>async1()</code> 时，返回一个 <code>Promise</code>，所以打印出来 <code>async2 end</code>。</li>
<li>每个 <code>await</code>，会新产生一个 <code>promise</code>,但这个过程本身是异步的，所以该 <code>await</code> 后面不会立即调用。</li>
<li>继续执行同步代码，打印 <code>Promise</code> 和 <code>script end</code>，将 <code>then</code> 函数放入微任务队列中等待执行。</li>
<li>同步执行完成之后，检查微任务队列是否为 <code>null</code>，然后按照先入先出规则，依次执行。</li>
<li>然后先执行打印 <code>promise1</code> ,此时 <code>then</code> 的回调函数返回 <code>undefinde</code>，此时又有 <code>then</code> 的链式调用，又放入微任务队列中，再次打印 <code>promise2</code>。</li>
<li>再回到 <code>await</code> 的位置执行返回的 <code>Promise</code> 的 <code>resolve</code> 函数，这又会把 <code>resolve</code> 丢到微任务队列中，打印 <code>async1 end</code>。</li>
<li>当微任务队列为空时，执行宏任务,打印 <code>setTimeout</code>。</li>
</ul>
<h5 id="谷歌（金丝雀73版本）"><a href="#谷歌（金丝雀73版本）" class="headerlink" title="谷歌（金丝雀73版本）"></a>谷歌（金丝雀73版本）</h5><ul>
<li>如果传递给 <code>await</code> 的值已经是一个 <code>Promise</code>，那么这种优化避免了再次创建 <code>Promise</code> 包装器，在这种情况下，我们从最少三个 <code>microtick</code> 到只有一个 <code>microtick</code>。</li>
<li>引擎不再需要为 <code>await</code> 创造 <code>throwaway Promise</code> - 在绝大部分时间。</li>
<li>现在 <code>promise</code> 指向了同一个 <code>Promise</code>，所以这个步骤什么也不需要做。然后引擎继续像以前一样，创建 <code>throwaway Promise</code>，安排 <code>PromiseReactionJob</code> 在 <code>microtask</code> 队列的下一个 <code>tick</code> 上恢复异步函数，暂停执行该函数，然后返回给调用者。</li>
</ul>
<p>具体详情查看（<a href="https://link.juejin.cn/?target=https://v8.js.cn/blog/fast-async/">这里</a>）。</p>
<h2 id="NodeJS的Event-Loop"><a href="#NodeJS的Event-Loop" class="headerlink" title="NodeJS的Event Loop"></a>NodeJS的Event Loop</h2><p><img src="https://user-images.githubusercontent.com/22131908/156738824-7245b774-4a0a-4307-a687-a553abde8cda.png" alt="image"><br><code>Node</code> 中的 <code>Event Loop</code> 是基于 <code>libuv</code> 实现的，而 <code>libuv</code> 是 <code>Node</code> 的新跨平台抽象层，<code>libuv</code> 使用异步，事件驱动的编程方式，核心是提供 <code>i/o</code> 的事件循环和异步回调。<code>libuv</code> 的 <code>API</code> 包含有时间，非阻塞的网络，异步文件操作，子进程等等。<br><code> Event Loop</code> 就是在 <code>libuv</code> 中实现的。<br><img src="https://user-images.githubusercontent.com/22131908/156738979-d42a43d2-ebbf-4084-b77f-3dc5d0e04c8a.png" alt="image"></p>
<h5 id="Node的Event-loop一共分为6个阶段，每个细节具体如下："><a href="#Node的Event-loop一共分为6个阶段，每个细节具体如下：" class="headerlink" title="Node的Event loop一共分为6个阶段，每个细节具体如下："></a>Node的Event loop一共分为6个阶段，每个细节具体如下：</h5><ul>
<li><code>timers</code>: 执行 <code>setTimeout</code> 和 <code>setInterval</code> 中到期的 <code>callback</code>。</li>
<li><code>pending callback</code> : 上一轮循环中少数的 <code>callback</code> 会放在这一阶段执行。</li>
<li><code>idle, prepare</code>: 仅在内部使用。</li>
<li><code>poll</code>: 最重要的阶段，执行 <code>pending callback</code> ，在适当的情况下回阻塞在这个阶段。</li>
<li><code>check</code>: 执行 <code>setImmediate</code> ( <code>setImmediate()</code> 是将事件插入到事件队列尾部，主线程和事件队列的函数执行完成之后立即执行 <code>setImmediate</code>指定的回调函数)的 <code>callback</code> 。</li>
<li><code>close callbacks</code> : 执行 <code>close</code> 事件的 <code>callback</code> ，例如 <code>socket.on(&#39;close&#39;[,fn])</code> 或者 <code>http.server.on(&#39;close, fn)</code>。</li>
</ul>
<p>具体细节如下：</p>
<h4 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h4><p>执行 <code>setTimeout</code> 和 <code>setInterval</code> 中到期的 <code>callback</code>，执行这两者回调需要设置一个毫秒数，理论上来说，应该是时间一到就立即执行 <code>callback</code> 回调，但是由于 <code>system</code> 的调度可能会延时，达不到预期时间。<br>以下是官网文档解释的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">someAsyncOperation</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="comment">// Assume this takes 95ms to complete</span></span><br><span class="line">  fs.<span class="title function_">readFile</span>(<span class="string">&#x27;/path/to/file&#x27;</span>, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeoutScheduled = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> delay = <span class="title class_">Date</span>.<span class="title function_">now</span>() - timeoutScheduled;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;delay&#125;</span>ms have passed since I was scheduled`</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// do someAsyncOperation which takes 95 ms to complete</span></span><br><span class="line"><span class="title function_">someAsyncOperation</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> startCallback = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do something that will take 10ms...</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="title class_">Date</span>.<span class="title function_">now</span>() - startCallback &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当进入事件循环时，它有一个空队列（ <code>fs.readFile()</code>尚未完成），因此定时器将等待剩余毫秒数，当到达 <code>95ms</code> 时，<code>fs.readFile()</code> 完成读取文件并且其完成需要 <code>10毫秒</code> 的回调被添加到轮询队列并执行。<br>当回调结束时，队列中不再有回调，因此事件循环将看到已达到最快定时器的阈值，然后回到 <code>timers</code> 阶段以执行定时器的回调。</p>
<p>在此示例中，您将看到正在调度的计时器与正在执行的回调之间的总延迟将为 <code>105毫秒</code>。</p>
<p><strong>以下是我测试时间：</strong><br><img src="https://user-images.githubusercontent.com/22131908/156739808-c9a26120-941c-4309-ba52-2aeb928ec080.png" alt="image"></p>
<h4 id="pending-callbacks"><a href="#pending-callbacks" class="headerlink" title="pending callbacks"></a>pending callbacks</h4><p>此阶段执行某些系统操作（例如TCP错误类型）的回调。 例如，如果 <code>TCP socket ECONNREFUSED</code> 在尝试 <code>connect</code> 时 <code>receives</code>，则某些* nix系统希望等待报告错误。 这将在 <code>pending callbacks</code> 阶段执行。</p>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p><strong>该poll阶段有两个主要功能：</strong></p>
<ul>
<li>执行I&#x2F;O回调。</li>
<li>处理轮询队列中的事件。</li>
</ul>
<p><strong>当事件循环进入 <code>poll</code> 阶段并且在 <code>timers</code> 中没有可以执行定时器时，将发生以下两种情况之一</strong></p>
<ul>
<li>如果 <code>poll</code> 队列不为空，则事件循环将遍历其同步执行它们的 <code>callback</code> 队列，直到队列为空，或者达到 <code>system-dependent</code>（系统相关限制）。</li>
</ul>
<p><strong>如果poll队列为空，则会发生以下两种情况之一</strong></p>
<ul>
<li><p>如果有 <code>setImmediate()</code> 回调需要执行，则会立即停止执行 <code>poll</code> 阶段并进入执行 <code>check</code> 阶段以执行回调。</p>
</li>
<li><p>如果没有 <code>setImmediate()</code> 回到需要执行，<code>poll</code> 阶段将等待 <code>callback</code> 被添加到队列中，然后立即执行。</p>
</li>
</ul>
<p><strong>当然设定了 <code>timer</code> 的话且 <code>poll</code> 队列为空，则会判断是否有 <code>timer</code> 超时，如果有的话会回到 <code>timer</code> 阶段执行回调。</strong></p>
<h4 id="check"><a href="#check" class="headerlink" title="check"></a>check</h4><p><strong>此阶段允许人员在 <code>poll</code> 阶段完成后立即执行回调。</strong><br>如果 <code>poll</code> 阶段闲置并且 <code>script</code> 已排队 <code>setImmediate()</code>，则事件循环到达 <code>check</code> 阶段执行而不是继续等待。</p>
<p><code>setImmediate()</code> 实际上是一个特殊的计时器，它在事件循环的一个单独阶段运行。它使用 <code>libuv API</code> 来调度在 <code>poll</code> 阶段完成后执行的回调。</p>
<p>通常，当代码被执行时，事件循环最终将达到 <code>poll</code> 阶段，它将等待传入连接，请求等。<br>但是，如果已经调度了回调 <code>setImmediate()</code> ，并且轮询阶段变为空闲，则它将结束并且到达 <code>check</code> 阶段，而不是等待 <code>poll</code> 事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer1&#x27;</span>)</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timer2&#x27;</span>)</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise3&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;end&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>如果 <code>node</code> 版本为 <code>v11.x</code>， 其结果与浏览器一致。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">promise3</span><br><span class="line">timer1</span><br><span class="line">promise1</span><br><span class="line">timer2</span><br><span class="line">promise2</span><br></pre></td></tr></table></figure>
<p>具体详情可以查看《<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903761979113479">又被node的eventloop坑了，这次是node的锅</a>》。</p>
<p>如果 <code>v10</code> 版本上述结果存在两种情况：</p>
<ul>
<li>如果 <code>time2</code> 定时器已经在执行队列中了<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">promise3</span><br><span class="line">timer1</span><br><span class="line">timer2</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br></pre></td></tr></table></figure></li>
<li>如果 <code>time2</code> 定时器没有在执行对列中，执行结果为<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">promise3</span><br><span class="line">timer1</span><br><span class="line">promise1</span><br><span class="line">timer2</span><br><span class="line">promise2</span><br></pre></td></tr></table></figure>
具体情况可以参考 <code>poll</code> 阶段的两种情况。</li>
</ul>
<p>从下图可能更好理解：<br><a target="_blank" rel="noopener" href="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/19/1686530bcd4e456a~tplv-t2oaga2asx-watermark.awebp">image</a></p>
<h2 id="setImmediate-的setTimeout-的区别"><a href="#setImmediate-的setTimeout-的区别" class="headerlink" title="setImmediate() 的setTimeout()的区别"></a>setImmediate() 的setTimeout()的区别</h2><p>** <code>setImmediate</code> 和 <code>setTimeout()</code> 是相似的，但根据它们被调用的时间以不同的方式表现。**</p>
<ul>
<li><code>setImmediate()</code> 设计用于在当前 <code>poll</code> 阶段完成后 <code>check</code> 阶段执行脚本 。</li>
<li><code>setTimeout()</code> 安排在经过最小（<code>ms</code>）后运行的脚本，在 <code>timers</code> 阶段执行。</li>
</ul>
<p><strong>举个例子</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;immediate&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>执行定时器的顺序将根据调用它们的上下文而有所不同。 如果从主模块中调用两者，那么时间将受到进程性能的限制。</strong></p>
<p><strong>其结果也不一致</strong></p>
<p><strong>如果在 <code>I / O</code> 周期内移动两个调用，则始终首先执行立即回调：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(__filename, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  <span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;immediate&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>其结果可以确定一定是 <code>immediate =&gt; timeout</code>。<br>主要原因是在 <code>I/O</code> 阶段读取文件后，事件循环会先进入 <code>poll</code> 阶段，发现有 <code>setImmediate</code> 需要执行，会立即进入 <code>check</code> 阶段执行<code>setImmediate</code> 的回调。<br>然后再进入 <code>timers</code> 阶段，执行 <code>setTimeout</code> ，打印 <code>timeout</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────────┐</span><br><span class="line">┌─&gt;│           timers          │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │     pending callbacks     │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │       idle, prepare       │</span><br><span class="line">│  └─────────────┬─────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌─────────────┴─────────────┐      │   incoming:   │</span><br><span class="line">│  │           poll            │&lt;─────┤  connections, │</span><br><span class="line">│  └─────────────┬─────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌─────────────┴─────────────┐      └───────────────┘</span><br><span class="line">│  │           check           │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">└──┤      close callbacks      │</span><br><span class="line">   └───────────────────────────┘</span><br></pre></td></tr></table></figure>
<h2 id="Process-nextTick"><a href="#Process-nextTick" class="headerlink" title="Process.nextTick()"></a>Process.nextTick()</h2><p>** <code>process.nextTick()</code> 虽然它是异步API的一部分，但未在图中显示。这是因为 <code>process.nextTick()</code> 从技术上讲，它不是事件循环的一部分。**</p>
<ul>
<li><code>process.nextTick()</code> 方法将 <code>callback</code> 添加到 <code>next tick</code> 队列。 一旦当前事件轮询队列的任务全部完成，在 <code>next tick</code> 队列中的所有 <code>callbacks</code> 会被依次调用。<br><strong>换种理解方式：</strong></li>
<li>当每个阶段完成后，如果存在 <code>nextTick</code> 队列，就会清空队列中的所有回调函数，并且优先于其他 <code>microtask</code> 执行。</li>
</ul>
<p><strong>例子</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setImmediate&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">someAsyncApiCall</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  process.<span class="title function_">nextTick</span>(callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">someAsyncApiCall</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bar&#x27;</span>, bar); <span class="comment">// 1</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bar = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>在 <code>NodeV10</code> 中上述代码执行可能有两种答案，一种为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bar <span class="number">1</span></span><br><span class="line"><span class="built_in">setTimeout</span></span><br><span class="line">setImmediate</span><br></pre></td></tr></table></figure>
<p>另一种为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bar <span class="number">1</span></span><br><span class="line">setImmediate</span><br><span class="line"><span class="built_in">setTimeout</span></span><br></pre></td></tr></table></figure>
<p>无论哪种，始终都是先执行 <code>process.nextTick(callback)</code> ，打印 <code>bar 1</code>。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>感谢@Dante_Hu提出这个问题 <code>await</code> 的问题，文章已经修正。 修改了node端执行结果。V10和V11的区别。<br><strong>关于await问题参考了以下文章：.</strong><br>《<a href="https://link.juejin.cn/?target=https://github.com/xianshenglu/blog/issues/60">promise, async, await, execution order</a>》<br>《<a href="https://link.juejin.cn/?target=https://github.com/tc39/ecma262/pull/1250">Normative: Reduce the number of ticks in async&#x2F;await</a>》<br>《<a href="https://link.juejin.cn/?target=https://www.zhihu.com/question/268007969">async&#x2F;await 在chrome 环境和 node 环境的 执行结果不一致，求解？</a>》<br>《<a href="https://link.juejin.cn/?target=https://v8.js.cn/blog/fast-async/">更快的异步函数和 Promise</a>》</p>
<p><strong>其他内容参考了：</strong><br>《<a href="https://link.juejin.cn/?target=https://segmentfault.com/a/1190000015559210">JS浏览器事件循环机制</a>》<br>《<a href="https://link.juejin.cn/?target=https://segmentfault.com/a/1190000010622146">什么是浏览器的事件循环（Event Loop）？</a>》<br>《<a href="https://link.juejin.cn/?target=https://segmentfault.com/a/1190000013861128">一篇文章教会你Event loop——浏览器和Node</a>》<br>《<a href="https://link.juejin.cn/?target=https://cnodejs.org/topic/5a9108d78d6e16e56bb80882">不要混淆nodejs和浏览器中的event loop</a>》<br>《<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903761949753352">浏览器与Node的事件循环(Event Loop)有何区别?</a>》<br>《<a href="https://link.juejin.cn/?target=https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">Tasks, microtasks, queues and schedules</a>》<br>《<a target="_blank" rel="noopener" href="https://juejin.cn/book/6844733763675488269/section/6844733763763568654#heading-3">前端面试之道</a>》<br>《<a href="https://link.juejin.cn/?target=https://www.jianshu.com/p/8e0ad01c41dc">Node.js介绍5-libuv的基本概念</a>》<br>《<a href="https://link.juejin.cn/?target=https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/">The Node.js Event Loop, Timers, and process.nextTick()</a>》<br>《<a href="https://link.juejin.cn/?target=http://nodejs.cn/">node官网</a>》</p>
<blockquote>
<p>本文摘自 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903764202094606">掘金</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/03/DOM-%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%81%E6%9C%BA%E5%88%B6%EF%BC%9A%E6%8D%95%E8%8E%B7%E4%B8%8E%E5%86%92%E6%B3%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/03/DOM-%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%81%E6%9C%BA%E5%88%B6%EF%BC%9A%E6%8D%95%E8%8E%B7%E4%B8%8E%E5%86%92%E6%B3%A1/" itemprop="url">DOM 的事件传送机制：捕获与冒泡</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-03T21:14:16+08:00">
                2020-06-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>今天为大家带来的内容是 DOM 里面的事件传递机制，而与这些事件相关的代码，相信大家应该不陌生，就是 <code>addEventListener</code>, <code>preventDefault</code> 和 <code>stopPropagation</code>。<br>简单来说，就是事件在 <code>DOM</code> 里面传输的顺序，以及你可以对这些事件做什么。</p>
<p>为什么会有 “传输顺序” 这一词呢？假设你有一个 <code>ul</code> 元素，底下有很多 <code>li</code>，代表不同的 <code>item</code>。当你点击任何一个 <code>li</code> 的时候，其实你也点击了 <code>ul</code>，因为 <code>ul</code> 把所有的 <code>li</code> 都包含了。</p>
<p>假如我在两个元素上面都加了 <code>eventListener</code>，哪一个会先执行？这个时候，知道事件的执行順序就很重要。</p>
<p>另外，由于某些浏览器（IE）的机制比较不一样，因此那些东西我完全不会提到，有兴趣的可以研究文末附的参考资料。</p>
<h2 id="2-简单范例"><a href="#2-简单范例" class="headerlink" title="2.简单范例"></a>2.简单范例</h2><p>为了之后方便说明，我们先写一个非常简单的范例出来：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;list_item&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;list_item_link&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://google.com&quot;</span>&gt;</span></span><br><span class="line">          google.com</span><br><span class="line">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这个范例里面，就是最外层一个 <code>ul</code>，再来 <code>li</code>，最后则是一个超链接。为了方便辨识，<code>id</code> 的取名也跟层级结构有关系。<code>DOM</code> 画成图大概是长这样：<br><img src="https://user-images.githubusercontent.com/22131908/156189120-187c3567-024e-4df7-93de-62c03beb7406.png" alt="image"><br>有了这个简单的 HTML 结构之后，就可以很清楚的说明 DOM 的事件传递机制了。</p>
<h2 id="3-事件的三个-Phase"><a href="#3-事件的三个-Phase" class="headerlink" title="3.事件的三个 Phase"></a>3.事件的三个 Phase</h2><p>要帮一个 DOM 加上 click 事件，你会这样写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $list = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>);</span><br><span class="line">$list.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;click!&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>而这里的 <code>e</code> 里面就包含了许多这次事件的相关参数，其中有一个叫做 <code>eventPhase</code>，是一个数字，表示这个事件在哪一个 <code>Phase</code> 触发。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $list = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>);</span><br><span class="line">$list.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">eventPhase</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>eventPhase</code> 的定义可以在 <a target="_blank" rel="noopener" href="https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface">DOM specification</a> 里面找到：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PhaseType</span></span><br><span class="line"><span class="keyword">const</span> unsigned short    <span class="variable constant_">CAPTURING_PHASE</span>   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> unsigned short    <span class="variable constant_">AT_TARGET</span>         = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> unsigned short    <span class="variable constant_">BUBBLING_PHASE</span>    = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>这三个阶段，就是我们今天的重点。</p>
<p>DOM 的事件在传播时，会先从根节点开始往下传递到 <code>target</code>，这边你如果加上事件的话，就会处于 <code>CAPTURING_PHASE</code>，捕获阶段。</p>
<p>target 就是你所点击的那个目标，这时候在 <code>target</code> 身上所加的 <code>eventListener</code> 会是 <code>AT_TARGET</code> 这一个 Phase</p>
<p>最后，事件再往上从子节点一路逆向传回根节点，这时候就叫做 <code>BUBBLING_PHASE</code>，也就是大家比较熟知的冒泡阶段。</p>
<p>这边用文字你可能会觉得云里雾里，直接引用一张 W3C <a target="_blank" rel="noopener" href="https://www.w3.org/TR/DOM-Level-3-Events/#event-flow">event flow</a> 的图，相信大家就清楚了。<br><img src="https://tie.pub/static/a97db545084746db37078b6ce4c91fe6/eventflow.svg" alt="image"></p>
<p>你点击那个 <code>td</code> 的时候，这个点击事件会先从 <code>window</code> 开始往下传，一直传到 <code>td</code> 为止，到这边就叫做 <code>CAPTURING_PHASE</code>，捕获阶段。接着事件传到 <code>td</code> 本身，这时候叫做 <code>AT_TARGET</code>。最后事件会从 <code>td</code> 一路传回 <code>window</code>，这时候叫做 <code>BUBBLING_PHASE</code>，冒泡阶段。</p>
<p>所以，再看一些将事件机制的文章的时候，都会看到一个口诀：先捕获，再冒泡。就是这样来的。</p>
<p>可是，我要怎么决定我要在捕获阶段还是冒泡阶段去监听这个事件呢？</p>
<p>其实，一样是用大家所熟悉的 <code>addEventListener</code>，只是这函数其实有第三个参数，<code>true</code> 代表把这个 <code>listener</code> 添加到捕获阶段，<code>false</code> 或是没有传参就代表把 <code>listener</code> 添加到冒泡阶段。</p>
<h2 id="4-实际演练"><a href="#4-实际演练" class="headerlink" title="4.实际演练"></a>4.实际演练</h2><p>大概知道事件的传递机制之后，我们拿上面写好的那个简单范例来示范一下，一样先附上事件传递的流程图（假设我们点击的对象是 <code>#list_item_link</code>）。<br><img src="https://user-images.githubusercontent.com/22131908/156188977-4c0cd4b0-3f61-4865-9980-85a0e5718136.png" alt="image"><br>接着，来试试看帮每个元素的每个阶段都添加事件，看一看结果跟我们想想的是否一样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">get</span> = (<span class="params">id</span>) =&gt; <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(id);</span><br><span class="line"><span class="keyword">const</span> $list = <span class="title function_">get</span>(<span class="string">&#x27;list&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> $list_item = <span class="title function_">get</span>(<span class="string">&#x27;list_item&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> $list_item_link = <span class="title function_">get</span>(<span class="string">&#x27;list_item_link&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// list 的捕获</span></span><br><span class="line">$list.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;list capturing&#x27;</span>, e.<span class="property">eventPhase</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// list 的冒泡</span></span><br><span class="line">$list.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;list bubbling&#x27;</span>, e.<span class="property">eventPhase</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// list_item 的捕获</span></span><br><span class="line">$list_item.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;list_item capturing&#x27;</span>, e.<span class="property">eventPhase</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// list_item 的冒泡</span></span><br><span class="line">$list_item.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;list_item bubbling&#x27;</span>, e.<span class="property">eventPhase</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// list_item_link 的捕获</span></span><br><span class="line">$list_item_link.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;list_item_link capturing&#x27;</span>, e.<span class="property">eventPhase</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// list_item_link 的冒泡</span></span><br><span class="line">$list_item_link.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;list_item_link bubbling&#x27;</span>, e.<span class="property">eventPhase</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>点一下超链接，console 输出以下结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;list capturing&#x27;</span>, <span class="number">1</span></span><br><span class="line"><span class="string">&#x27;list_item capturing&#x27;</span>, <span class="number">1</span></span><br><span class="line"><span class="string">&#x27;list_item_link capturing&#x27;</span>, <span class="number">2</span></span><br><span class="line"><span class="string">&#x27;list_item_link bubbling&#x27;</span>, <span class="number">2</span></span><br><span class="line"><span class="string">&#x27;list_item bubbling&#x27;</span>, <span class="number">3</span></span><br><span class="line"><span class="string">&#x27;list bubbling&#x27;</span>, <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>1 是 <code>CAPTURING_PHASE</code>，2 是 <code>AT_TARGET</code>，3 是 <code>BUBBLING_PHASE</code>。<br>从这里就可以很明晰看出，时间的确是从最上层一直传递到 <code>target</code>，而在这传递的过程里，我们用 <code>addEventListener</code> 的第三个参数把 listener 添加在 <code>CAPTURING_PHASE</code>。</p>
<p>然后事件传递到我们点击的超链接（<code>a#list_item_link</code>）本身，在这里无论你设置 <code>addEventListener</code> 的第三个参数是 <code>true</code> 还是 <code>false</code>，这里的 <code>e.eventPhase</code> 都会变成 <code>AT_TARGET</code>。</p>
<p>最后，在从 <code>target</code> 不断冒泡传回去，先传到上一层的 <code>#list_item</code>，再传到上上层的 <code>#list</code>。</p>
<h2 id="5-先捕获，再冒泡的小陷阱"><a href="#5-先捕获，再冒泡的小陷阱" class="headerlink" title="5.先捕获，再冒泡的小陷阱"></a>5.先捕获，再冒泡的小陷阱</h2><p>既然是先捕获，再冒泡，意思是无论那些 <code>addEventListener</code> 的顺序怎么变，输出的东西应该还是一样才对。我们把捕获跟冒泡的顺序对调，看一下输出的结果是否一样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">get</span> = (<span class="params">id</span>) =&gt; <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(id);</span><br><span class="line"><span class="keyword">const</span> $list = <span class="title function_">get</span>(<span class="string">&#x27;list&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> $list_item = <span class="title function_">get</span>(<span class="string">&#x27;list_item&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> $list_item_link = <span class="title function_">get</span>(<span class="string">&#x27;list_item_link&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// list 的冒泡</span></span><br><span class="line">$list.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;list bubbling&#x27;</span>, e.<span class="property">eventPhase</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// list 的捕獲</span></span><br><span class="line">$list.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;list capturing&#x27;</span>, e.<span class="property">eventPhase</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// list_item 的冒泡</span></span><br><span class="line">$list_item.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;list_item bubbling&#x27;</span>, e.<span class="property">eventPhase</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// list_item 的捕獲</span></span><br><span class="line">$list_item.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;list_item capturing&#x27;</span>, e.<span class="property">eventPhase</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// list_item_link 的冒泡</span></span><br><span class="line">$list_item_link.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;list_item_link bubbling&#x27;</span>, e.<span class="property">eventPhase</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// list_item_link 的捕獲</span></span><br><span class="line">$list_item_link.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;list_item_link capturing&#x27;</span>, e.<span class="property">eventPhase</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>同样点击超链接，输出结果是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;list capturing&#x27;</span>, <span class="number">1</span></span><br><span class="line"><span class="string">&#x27;list_item capturing&#x27;</span>, <span class="number">1</span></span><br><span class="line"><span class="string">&#x27;list_item_link bubbling&#x27;</span>, <span class="number">2</span></span><br><span class="line"><span class="string">&#x27;list_item_link capturing&#x27;</span>, <span class="number">2</span></span><br><span class="line"><span class="string">&#x27;list_item bubbling&#x27;</span>, <span class="number">3</span></span><br><span class="line"><span class="string">&#x27;list bubbling&#x27;</span>, <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>可以发现一件神奇的事，那就是 <code>list_item_link</code> 居然是先执行了添加在冒泡阶段的 <code>listener</code>，才执行捕获阶段的 <code>listener</code>。</p>
<p>这是为什么呢？其实刚刚上面有提到，当事件传递到点击的真正对象，也就是 <code>e.target</code> 的时候，无论你是使用 <code>addEventListener</code> 的第三个参数是 <code>true</code> 还是 <code>false</code>，这里的 <code>e.eventPhase</code> 都会变成 <code>AT_TARGET</code>。</p>
<p>既然这里已经编成 <code>AT_TARGET</code>，自然就没有什么捕获跟冒泡之分，所以执行顺序就会根据你 <code>addEventListener</code> 的顺序而定，先添加的先添加的先执行，后添加的后执行。</p>
<p>所以，这就是为什么我们上面把捕获跟冒泡的顺序换了以后，会先出现 list_item_link bubbling 的原因。</p>
<p>关于事件的传递顺序，只要记住两个原则就好：</p>
<ul>
<li>先捕获，再冒泡</li>
<li>当事件传到 target 本身，沒有分捕获跟冒泡</li>
</ul>
<h2 id="6-取消事件传递"><a href="#6-取消事件传递" class="headerlink" title="6.取消事件传递"></a>6.取消事件传递</h2><p>接着要讲的是，这一串事件链这么长，一定有方法可以中断，让事件的传递不再继续，而这个方法就是 <code>e.stopPropagation</code>。</p>
<p>这个方法及在哪边，事件的传递就断在哪里，不会再继续往下传递。</p>
<p>例如说以上那个例子来讲，假如我加在 <code>#list</code> 的捕获阶段：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list 的捕獲</span></span><br><span class="line">$list.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;list capturing&#x27;</span>, e.<span class="property">eventPhase</span>);</span><br><span class="line">    e.<span class="title function_">stopPropagation</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这样，<code>console</code> 就只会输出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;list capturing&#x27;</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>因为事件的传递被停止，所以剩下的 <code>listener</code> 都不会再收到任何的事件。</p>
<p>不过，这里依然有一个地方要特别注意。这里指的 “事件传递被停止” 的意思不是说不会再把事件传递给 “下一个节点”，但若是你在同一个节点上有不止一个 <code>listener</code>，还是会被执行到。</p>
<p>例如说：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list 的捕獲</span></span><br><span class="line">$list.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;list capturing&#x27;</span>);</span><br><span class="line">    e.<span class="title function_">stopPropagation</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// list 的捕獲 2</span></span><br><span class="line">$list.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;list capturing2&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>输出的结果是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list capturing</span><br><span class="line">list capturing2</span><br></pre></td></tr></table></figure>
<p>尽管已经使用 <code>e.stopPropagation</code>，但对于同一层级，剩下的 <code>listener</code> 还是会被执行到。</p>
<p>若不想同一级的其它 <code>listener</code> 被执行，可以改用 <code>e.stopImmediatePropagation()</code>。比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list 的捕獲</span></span><br><span class="line">$list.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;list capturing&#x27;</span>);</span><br><span class="line">    e.<span class="title function_">stopImmediatePropagation</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// list 的捕獲 2</span></span><br><span class="line">$list.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;list capturing2&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>结果输出：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list capturing</span><br></pre></td></tr></table></figure>
<h2 id="7-取消默认行为"><a href="#7-取消默认行为" class="headerlink" title="7.取消默认行为"></a>7.取消默认行为</h2><p>常常有人搞不清楚 <code>e.stopPropagation</code> 与 <code>e.preventDefault</code> 的区别，前者刚刚已经说明了，就是取消事件往下继续传递，而后者则是取消浏览器的默认行为。</p>
<p>最常见的做法是阻止超链接跳转：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list_item_link 的冒泡</span></span><br><span class="line">$list_item_link.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这样，当点击超链接的时候，就不会执行原本的默认行为（新开分页或者跳转），而是不做任何行为，这就是 preventDefault 的作用。</p>
<p>所以说，preventDefault 与 JavaScript 的事件传递一点关系都没有，加上这一行后，事件还会继续往下传递。</p>
<p>需要注意的地方是 W3C 文件里面写道：</p>
<blockquote>
<p>Once preventDefault has been called it will remain in effect throughout the remainder of the event’s propagation.</p>
</blockquote>
<p>意思是说一旦执行了 <code>preventDefault</code>，这之后传递下去的事件里面也会有效果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list 的捕獲</span></span><br><span class="line">$list.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;list capturing&#x27;</span>, e.<span class="property">eventPhase</span>);</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>我们在 <code>#list</code> 的捕获事件里面执行了 <code>e.preventDefault()</code>，而根据文件上面所说的，这个效果会在之后的传递事件里面一直延续。因此，之后事件传递到 <code>#list_item_link</code> 的时候，会发现点超链接一样没反应。</p>
<h2 id="8-实际应用"><a href="#8-实际应用" class="headerlink" title="8.实际应用"></a>8.实际应用</h2><p>知道了事件的传递机制、取消传递事件和取消默认行为之后，在实际开发上有什么用处呢？</p>
<p>最常见的用法其实就是时间代理（<code>Delegation</code>），例如有一个 <code>ul</code>，包裹着 1000 个 <code>li</code>，如果帮每个 <code>li</code> 绑定 <code>eventListener</code>，就新建了 1000 个 <code>function</code>。但是我们已经了解，任何点击 <code>li</code> 的事件都会传到 <code>ul</code> 上，于是可以在 <code>ul</code> 上绑定一个 <code>listener</code> 就好。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">data-index</span>=<span class="string">&quot;1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">data-index</span>=<span class="string">&quot;2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">data-index</span>=<span class="string">&quot;3&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    .<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>.<span class="title function_">getAttribute</span>(<span class="string">&#x27;data-index&#x27;</span>));</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>而这样的另一个好处是当新增或者删除某一个 <code>li</code> 的时候，不用去处理那个元素相关的 <code>listener</code>，因为 <code>listener</code> 是在 <code>ul</code> 上代理。这样透过父节点来处理子节点的事件，就叫做事件代理。</p>
<p>除此之外，有一个有趣的应用，在知道原理后，我们可以这样使用 <code>e.preventDefault()</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">    e.<span class="title function_">stopPropagation</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>只要这样一段代码，就可以把页面上的所有元素的点击事件停用，像 <code>&lt;a&gt;</code> 点击也不会跳转链接，<code>&lt;form&gt;</code> 按了 <code>submit</code> 没反应，因为阻止了事件冒泡，其它的 <code>onClick</code> 事件都不会执行。</p>
<p>或者，也可以这样用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>利用事件传递机制的特性，在 <code>window</code> 上面使用捕获，就能保证一定是第一个被执行的事件，就可以在这个 <code>function</code> 里面监听页面中每个元素的点击，可以传送到服务端做数据统计及分析。</p>
<h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9.总结"></a>9.总结</h2><p>DOM 的事件传递机制算是 JavaScript 众多经典面试题里面相对简单很多的，只要掌握事件传递的原则跟顺序，其实就差不多。</p>
<p>而 <code>e.preventDefault</code> 与 <code>e.stopPropagation</code> 的区别在知道事件传递顺序之后也容易理解，前者只是取消默认行为，与事件传递没有关系，后者是让事件不再往下传递。</p>
<h2 id="10-参考资料"><a href="#10-参考资料" class="headerlink" title="10.参考资料"></a>10.参考资料</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bfgis/p/5460191.html">JavaScript 详说事件机制之冒泡、捕获、传播、委托</a><br><a target="_blank" rel="noopener" href="https://github.com/zhukejin1223/blogs/blob/master/JAVASCRIPT/Javascript-event.md">Javascript 事件冒泡和捕获的一些探讨</a><br><a target="_blank" rel="noopener" href="http://wiki.jikexueyuan.com/project/brief-talk-js/event-cancellation-and-prevent-bubbles.html">浅谈 javascript 事件取消和阻止冒泡</a><br><a target="_blank" rel="noopener" href="https://www.sitepoint.com/event-bubbling-javascript/">What Is Event Bubbling in JavaScript? Event Propagation Explained</a><br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/4616694/what-is-event-bubbling-and-capturing">What is event bubbling and capturing?</a><br><a target="_blank" rel="noopener" href="https://www.quirksmode.org/js/events_order.html">Event order</a><br><a target="_blank" rel="noopener" href="https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-flow-capture">Document Object Model Events</a></p>
<blockquote>
<p>本文作者 Huli，转载请注明来源链接：<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.huli.tw/2017/08/27/dom-event-capture-and-propagation/">https://blog.huli.tw/2017/08/27/dom-event-capture-and-propagation/</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/rhwoodpecker" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:rhwoodpecker@163.com" target="_blank" title="E-Mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                    
                      E-Mail
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ren Hao</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
