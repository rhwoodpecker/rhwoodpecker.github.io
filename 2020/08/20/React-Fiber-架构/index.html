<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="react,fiber," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="一、Fiber 架构诞生 当项目变得庞大、组件数量繁多、遇到大计算量的操作或者设备性能不足使得页面掉帧，导致卡顿。  React 渲染页面的两个阶段 调度阶段（reconciliation）：在这个阶段 React 会更新数据生成新的 Virtual DOM，然后通过Diff算法，快速找出需要更新的元素，放到更新队列中去，得到新的更新队列。 渲染阶段（commit）：这个阶段 React 会遍历更">
<meta property="og:type" content="article">
<meta property="og:title" content="React Fiber 架构">
<meta property="og:url" content="http://example.com/2020/08/20/React-Fiber-%E6%9E%B6%E6%9E%84/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="一、Fiber 架构诞生 当项目变得庞大、组件数量繁多、遇到大计算量的操作或者设备性能不足使得页面掉帧，导致卡顿。  React 渲染页面的两个阶段 调度阶段（reconciliation）：在这个阶段 React 会更新数据生成新的 Virtual DOM，然后通过Diff算法，快速找出需要更新的元素，放到更新队列中去，得到新的更新队列。 渲染阶段（commit）：这个阶段 React 会遍历更">
<meta property="og:locale">
<meta property="og:image" content="https://user-images.githubusercontent.com/22131908/157614057-0c85af9d-ad97-4090-8fe0-ee031c5c2997.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/22131908/157614111-be7bb520-dd8f-4621-951e-7875961f6a48.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/22131908/157614149-214aa1a1-7ceb-4d30-bead-b5314c90c634.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/22131908/157614271-904633c8-1b10-4f4b-9c5f-12c53b1233a6.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/22131908/157621232-0dad5503-f967-474f-b89d-b469a86bb252.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/22131908/157621660-db4cf254-01f0-4584-b0e9-05887940fa0c.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/22131908/157622436-bb9c2801-e5e6-4086-82e3-828a96128fe1.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/22131908/157636984-c4d8c93c-b92f-4c39-a232-a43bc09e11ca.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/22131908/157636890-18bf3b72-ab12-4380-b999-b40f43e2c750.png">
<meta property="article:published_time" content="2020-08-20T08:03:37.000Z">
<meta property="article:modified_time" content="2023-03-06T03:59:33.116Z">
<meta property="article:author" content="Ren Hao">
<meta property="article:tag" content="react">
<meta property="article:tag" content="fiber">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-images.githubusercontent.com/22131908/157614057-0c85af9d-ad97-4090-8fe0-ee031c5c2997.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":5},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/2020/08/20/React-Fiber-架构/"/>





  <title>React Fiber 架构 | 个人博客</title>
  














<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/08/20/React-Fiber-%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">React Fiber 架构</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-20T16:03:37+08:00">
                2020-08-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="一、Fiber-架构诞生"><a href="#一、Fiber-架构诞生" class="headerlink" title="一、Fiber 架构诞生"></a>一、Fiber 架构诞生</h2><ul>
<li>当项目变得庞大、组件数量繁多、遇到大计算量的操作或者设备性能不足使得页面掉帧，导致卡顿。</li>
</ul>
<h3 id="React-渲染页面的两个阶段"><a href="#React-渲染页面的两个阶段" class="headerlink" title="React 渲染页面的两个阶段"></a>React 渲染页面的两个阶段</h3><ul>
<li>调度阶段（<code>reconciliation</code>）：在这个阶段 <code>React</code> 会更新数据生成新的 <code>Virtual DOM</code>，然后通过<strong>Diff</strong>算法，快速找出需要更新的元素，放到更新队列中去，得到新的更新队列。</li>
<li>渲染阶段（<code>commit</code>）：这个阶段 <code>React</code> 会遍历更新队列，将其所有的变更一次性更新到 <code>DOM</code> 上。<span id="more"></span></li>
</ul>
<h3 id="React-15-架构"><a href="#React-15-架构" class="headerlink" title="React 15 架构"></a>React 15 架构</h3><p><strong>React15架构可以分为两层</strong>：</p>
<ul>
<li><strong>Reconciler</strong>（协调器）—— 负责找出变化的组件；</li>
<li><strong>Renderer</strong>（渲染器）—— 负责将变化的组件渲染到页面上；</li>
</ul>
<p>  在React15及以前，<code>Reconciler</code> 采用递归的方式创建<strong>虚拟DOM</strong>，递归过程是不能中断的。如果组件树的层级很深，递归会占用线程很多时间，递归更新时间超过了 <code>16ms</code>，用户交互就会卡顿。<br>  为了解决这个问题，<code>React16</code> 将递归的无法中断的更新重构为异步的可中断更新，由于曾经用于递归的<strong>虚拟DOM</strong>数据结构已经无法满足需要。于是，全新的 <code>Fiber</code> 架构应运而生。</p>
<h3 id="React-16-架构"><a href="#React-16-架构" class="headerlink" title="React 16 架构"></a>React 16 架构</h3><p>为了解决同步更新长时间占用线程导致页面卡顿的问题，也为了探索运行时优化的更多可能，React开始重构并一直持续至今。重构的目标是实现 <code>Concurrent Mode</code>（<strong>并发模式</strong>）。</p>
<p>从 <code>v15</code> 到 <code>v16</code>，React团队花了两年时间将源码架构中的 <code>Stack Reconciler</code> 重构为 <code>Fiber Reconciler</code>。<br>React16架构可以分为三层：</p>
<ul>
<li><strong>Scheduler</strong>（调度器）—— 调度任务的优先级，高优任务优先进入 <code>Reconciler</code>；</li>
<li><strong>Reconciler</strong>（协调器）—— 负责找出变化的组件：更新工作从递归变成了可以中断的循环过程。<code>Reconciler</code> 内部采用了 <code>Fiber</code> 的架构；</li>
<li><strong>Renderer</strong>（渲染器）—— 负责将变化的组件渲染到页面上。</li>
</ul>
<h3 id="React-17-优化"><a href="#React-17-优化" class="headerlink" title="React 17 优化"></a>React 17 优化</h3><p><code>React16</code>的 <code>expirationTimes</code> 模型只能区分是否 <code>&gt;=expirationTimes</code> 决定节点是否更新。<code>React17</code> 的 <code>lanes</code> 模型可以选定一个更新区间，并且动态的向区间中增减优先级，可以处理更细粒度的更新。</p>
<blockquote>
<p>Lane用<strong>二进制位</strong>表示任务的优先级，方便优先级的计算（位运算），不同优先级占用不同位置的“赛道”，而且存在批的概念，优先级越低，“赛道”越多。高优先级打断低优先级，新建的任务需要赋予什么优先级等问题都是Lane所要解决的问题。\</p>
</blockquote>
<p><strong>Concurrent Mode的目的是实现一套可中断&#x2F;恢复的更新机制。其由两部分组成：</strong></p>
<ul>
<li>一套协程架构：<code>Fiber Reconciler</code></li>
<li>基于协程架构的启发式更新算法：控制协程架构工作方式的算法</li>
</ul>
<h2 id="二、Fiber-架构"><a href="#二、Fiber-架构" class="headerlink" title="二、Fiber 架构"></a>二、Fiber 架构</h2><p><code>Fiber</code> 的英文含义是“纤维”，它是比线程（<code>Thread</code>）更细的线，比线程（<code>Thread</code>）控制得更精密的执行模型。在广义计算机科学概念中，Fiber 又是一种协作的（<code>Cooperative</code>）编程模型（<strong>协程</strong>），帮助开发者用一种<strong>【既模块化又协作化】</strong>的方式来编排代码。</p>
<p>在 <code>React</code> 中，<code>Fiber</code> 就是 <code>React 16</code> 实现的一套新的更新机制，让 <code>React</code> 的<strong>更新过程变得可控</strong>，避免了之前采用递归需要一气呵成影响性能的做法</p>
<h3 id="React-Fiber-时间分片"><a href="#React-Fiber-时间分片" class="headerlink" title="React Fiber 时间分片"></a>React Fiber 时间分片</h3><p>把一个<strong>耗时长的任务分成很多小片</strong>，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都<strong>给其他任务一个执行的机会</strong>，这样唯一的线程就不会被独占，其他任务依然有运行的机会。</p>
<p><code>React Fiber</code> 把更新过程<strong>碎片化</strong>，每执行完一段更新过程，就把控制权交还给 <code>React</code> 负责任务协调的模块，看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。</p>
<h3 id="React-15-的-Stack-Reconciler"><a href="#React-15-的-Stack-Reconciler" class="headerlink" title="React 15 的 Stack Reconciler"></a>React 15 的 Stack Reconciler</h3><p>基于<strong>栈</strong>的 <code>Reconciler</code>，浏览器引擎会从执行栈的顶端开始执行，执行完毕就弹出当前执行上下文，开始执行下一个函数，<strong>直到执行栈被清空才会停止</strong>。然后将执行权交还给浏览器。由于 React 将页面视图视作一个个函数执行的结果。每一个页面往往由多个视图组成，这就意味着多个函数的调用。</p>
<p>如果一个页面足够复杂，形成的函数调用栈就会很深。每一次更新，执行栈需要一次性执行完成，中途不能干其他的事儿，只能”<strong>一心一意</strong>“。结合前面提到的浏览器刷新率，JS 一直执行，浏览器得不到控制权，就不能及时开始下一帧的绘制。如果这个时间超过<br> <code>16ms</code>，当页面有动画效果需求时，动画因为浏览器<strong>不能及时绘制下一帧</strong>，这时动画就会出现卡顿。不仅如此，因为事件响应代码是在每一帧开始的时候执行，如果不能及时绘制下一帧，事件响应也会延迟。</p>
<h3 id="React-16-的-Fiber-Reconciler"><a href="#React-16-的-Fiber-Reconciler" class="headerlink" title="React 16 的 Fiber Reconciler"></a>React 16 的 Fiber Reconciler</h3><p><strong>链表结构</strong><br>在 <code>React Fiber</code> 中用<strong>链表</strong>遍历的方式替代了 <code>React 16</code> 之前的栈递归方案。在 <code>React 16</code> 中使用了大量的<strong>链表</strong>。</p>
<blockquote>
<p>使用多向链表的形式替代了原来的树结构</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;A&quot;</span>&gt;</span><br><span class="line">  <span class="variable constant_">A1</span></span><br><span class="line">  &lt;div id=<span class="string">&quot;B1&quot;</span>&gt;</span><br><span class="line">    <span class="variable constant_">B1</span></span><br><span class="line">    &lt;div id=<span class="string">&quot;C1&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;B2&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    B2</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/22131908/157614057-0c85af9d-ad97-4090-8fe0-ee031c5c2997.png" alt="image"></p>
<blockquote>
<p>副作用单链表</p>
</blockquote>
<p><img src="https://user-images.githubusercontent.com/22131908/157614111-be7bb520-dd8f-4621-951e-7875961f6a48.png" alt="image"></p>
<blockquote>
<p>状态更新单链表</p>
</blockquote>
<p><img src="https://user-images.githubusercontent.com/22131908/157614149-214aa1a1-7ceb-4d30-bead-b5314c90c634.png" alt="image"></p>
<blockquote>
<p>延伸：链表是一种简单高效的数据结构，它在当前节点中保存着指向下一个节点的指针；遍历的时候，通过操作指针找到下一个元素。</p>
</blockquote>
<p><img src="https://user-images.githubusercontent.com/22131908/157614271-904633c8-1b10-4f4b-9c5f-12c53b1233a6.png" alt="image"></p>
<p>链表相比顺序结构数据格式的<strong>好处</strong>就是：</p>
<ol>
<li>操作更高效，比如顺序调整、删除，只需要改变节点的指针指向就好了。</li>
<li>不仅可以根据当前节点找到下一个节点，在多向链表中，还可以找到他的父节点或者兄弟节点。</li>
</ol>
<p>但链表也不是完美的，<strong>缺点</strong>就是：</p>
<ol>
<li>比顺序结构数据更占用空间，因为每个节点对象还保存有指向下一个对象的指针。</li>
<li>不能自由读取，必须找到他的上一个节点。</li>
</ol>
<p>React 用<strong>空间换时间</strong>，更高效的操作可以方便根据优先级进行操作。同时<strong>可以根据当前节点找到其他节点，在下面提到的挂起和恢复过程中起到了关键作用</strong>。</p>
<h2 id="三、React-Fiber-如何实现更新过程可控"><a href="#三、React-Fiber-如何实现更新过程可控" class="headerlink" title="三、React Fiber 如何实现更新过程可控"></a>三、React Fiber 如何实现更新过程可控</h2><p>更新过程的可控主要体现在下面几个方面：</p>
<ul>
<li>任务拆分</li>
<li>任务挂起、恢复、终止</li>
<li>任务具备优先级</li>
</ul>
<h3 id="任务拆分"><a href="#任务拆分" class="headerlink" title="任务拆分"></a>任务拆分</h3><p>在 <code>React Fiber</code> 机制中，它采用”化整为零”的思想，将调和阶段（Reconciler）递归遍历 VDOM 这个大任务分成若干小任务，每个任务只负责一个节点的处理。</p>
<h3 id="任务挂起、恢复、终止"><a href="#任务挂起、恢复、终止" class="headerlink" title="任务挂起、恢复、终止"></a>任务挂起、恢复、终止</h3><blockquote>
<p>workInProgress tree</p>
</blockquote>
<p><code>workInProgress</code> 代表<strong>当前正在执行更新的 <code>Fiber</code> 树</strong>。在 <code>render</code> 或者 <code>setState</code> 后，会构建一颗 <code>Fiber</code> 树，也就是 <code>workInProgress tree</code>，这棵树在构建每一个节点的时候会<strong>收集当前节点的副作用</strong>，整棵树构建完成后，会形成一条完整的<strong>副作用链</strong>。</p>
<blockquote>
<p>currentFiber tree</p>
</blockquote>
<p><code>currentFiber</code> 表示<strong>上次渲染构建的 <code>Filber</code> 树</strong>。**在每一次更新完成后 <code>workInProgress</code> 会赋值给 <code>currentFiber</code> **。在新一轮更新时 <code>workInProgress tree</code> 再重新构建，新 <code>workInProgress</code> 的节点通过 <code>alternate</code> 属性和 <code>currentFiber</code> 的节点建立联系。</p>
<p>在新 <code>workInProgress tree</code> 的创建过程中，会同 <code>currentFiber</code> 的对应节点进行 <code>Diff</code> 比较，收集副作用。同时也会<strong>复用</strong>和 <code>currentFiber</code> 对应的节点对象，减少新创建对象带来的开销。也就是说<strong>无论是创建还是更新、挂起、恢复以及终止操作都是发生在 <code>workInProgress tree</code> 创建过程中的</strong>。<code>workInProgress tree</code> 构建过程其实就是循环的执行任务和创建下一个任务。</p>
<h4 id="挂起"><a href="#挂起" class="headerlink" title="挂起"></a>挂起</h4><p>当第一个小任务完成后，先判断这一帧是否还有<strong>空闲时间</strong>，没有就挂起下一个任务的执行，<strong>记住</strong>当前挂起的节点，让出控制权给浏览器执行更高优先级的任务。</p>
<h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><p>在浏览器渲染完一帧后，判断当前帧是否有<strong>剩余时间</strong>，如果有就恢复执行之前挂起的任务。如果没有任务需要处理，代表调和阶段完成，可以开始进入渲染阶段。</p>
<ol>
<li>如何判断一帧是否有空闲时间的呢？</li>
</ol>
<p>使用前面提到的 <code>RIC (RequestIdleCallback)</code> 浏览器原生 <code>API</code>，<code>React</code> 源码中为了兼容低版本的浏览器，对该方法进行了 <code>Polyfill</code>。</p>
<ol start="2">
<li>恢复执行的时候又是如何知道下一个任务是什么呢？</li>
</ol>
<p>答案是在前面提到的<strong>链表</strong>。在 <code>React Fiber</code> 中每个任务其实就是在处理一个 <code>FiberNode</code> 对象，然后又生成下一个任务需要处理的 <code>FiberNode</code>。</p>
<h4 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h4><p>其实并不是每次更新都会走到提交阶段。当在调和过程中触发了新的更新，在执行下一个任务的时候，判断<strong>是否有优先级更高的执行任务</strong>，如果有就终止原来将要执行的任务，开始新的 <code>workInProgressFiber</code> 树构建过程，开始新的更新流程。这样可以避免重复更新操作。这也是<strong>在 <code>React 16</code> 以后生命周期函数 <code>componentWillMount</code> 有可能会执行多次</strong>的原因。<br><img src="https://user-images.githubusercontent.com/22131908/157621232-0dad5503-f967-474f-b89d-b469a86bb252.png" alt="image"></p>
<h3 id="任务具备优先级"><a href="#任务具备优先级" class="headerlink" title="任务具备优先级"></a>任务具备优先级</h3><p><code>React Fiber</code> 除了通过挂起，恢复和终止来控制更新外，还给每个任务分配了优先级。具体点就是在创建或者更新 <code>FiberNode</code> 的时候，通过算法给每个任务分配一个到期时间（<code>expirationTime</code>）。在每个任务执行的时候除了判断剩余时间，如果当前处理节点已经过期，那么无论现在是否有空闲时间都必须执行该任务。<strong>过期时间的大小还代表着任务的优先级</strong>。</p>
<p><strong>任务在执行过程中顺便收集了每个 <code>FiberNode</code> 的副作用</strong>，将有副作用的节点通过 <code>firstEffect</code>、<code>lastEffect</code>、<code>nextEffect</code> 形成一条副作用单链表 <code>A1(TEXT)-B1(TEXT)-C1(TEXT)-C1-C2(TEXT)-C2-B1-B2(TEXT)-B2-A</code>。</p>
<p>其实<strong>最终都是为了收集到这条副作用链表，有了它，在接下来的渲染阶段就通过遍历副作用链完成 <code>DOM</code> 更新</strong>。这里需要注意，更新真实 <code>DOM</code> 的这个动作是<strong>一气呵成</strong>的，不能中断，不然会造成视觉上的不连贯（<code>commit</code>）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;A1&quot;</span>&gt;</span><br><span class="line">  <span class="variable constant_">A1</span></span><br><span class="line">  &lt;div id=<span class="string">&quot;B1&quot;</span>&gt;</span><br><span class="line">    <span class="variable constant_">B1</span></span><br><span class="line">    &lt;div id=<span class="string">&quot;C1&quot;</span>&gt;<span class="variable constant_">C1</span>&lt;/div&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;C2&quot;</span>&gt;</span>C2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;B2&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    B2</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/22131908/157621660-db4cf254-01f0-4584-b0e9-05887940fa0c.png" alt="image"></p>
<h2 id="四、Fiber结构长什么样"><a href="#四、Fiber结构长什么样" class="headerlink" title="四、Fiber结构长什么样"></a>四、Fiber结构长什么样</h2><p>基于时间分片的增量更新需要<strong>更多的上下文信息</strong>，之前的 <code>vDOM tree</code> 显然难以满足，所以扩展出了 <code>fiber tree</code>（即 <code>Fiber</code>上下文的 <code>vDOM tree</code> ），更新过程就是根据输入数据以及现有的 <code>fiber tree</code> 构造出新的 <code>fiber tree</code> （ <code>workInProgress tree</code> ）。</p>
<p><code>FiberNode</code> 上的属性有很多，根据笔者的理解，以下这么几个属性是值得关注的：<code>return</code>、<code>child</code>、<code>sibling</code>（主要负责 <code>fiber</code> 链表的链接）；<code>stateNode</code>；<code>effectTag</code>；<code>expirationTime</code>；<code>alternate</code>；<code>nextEffect</code>。各属性介绍参看下面的 <code>class FiberNode</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FiberNode</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">tag, pendingProps, key, mode</span>) &#123;</span><br><span class="line">    <span class="comment">// 实例属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tag</span> = tag; <span class="comment">// 标记不同组件类型，如函数组件、类组件、文本、原生组件...</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = key; <span class="comment">// react 元素上的 key 就是 jsx 上写的那个 key ，也就是最终 ReactElement 上的</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">elementType</span> = <span class="literal">null</span>; <span class="comment">// createElement的第一个参数，ReactElement 上的 type</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">type</span> = <span class="literal">null</span>; <span class="comment">// 表示fiber的真实类型 ，elementType 基本一样，在使用了懒加载之类的功能时可能会不一样</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stateNode</span> = <span class="literal">null</span>; <span class="comment">// 实例对象，比如 class 组件 new 完后就挂载在这个属性上面，如果是RootFiber，那么它上面挂的是 FiberRoot,如果是原生节点就是 dom 对象</span></span><br><span class="line">    <span class="comment">// fiber</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">return</span> = <span class="literal">null</span>; <span class="comment">// 父节点，指向上一个 fiber</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">child</span> = <span class="literal">null</span>; <span class="comment">// 子节点，指向自身下面的第一个 fiber</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sibling</span> = <span class="literal">null</span>; <span class="comment">// 兄弟组件, 指向一个兄弟节点</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">index</span> = <span class="number">0</span>; <span class="comment">//  一般如果没有兄弟节点的话是0 当某个父节点下的子节点是数组类型的时候会给每个子节点一个 index，index 和 key 要一起做 diff</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">ref</span> = <span class="literal">null</span>; <span class="comment">// reactElement 上的 ref 属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pendingProps</span> = pendingProps; <span class="comment">// 新的 props</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">memoizedProps</span> = <span class="literal">null</span>; <span class="comment">// 旧的 props</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">updateQueue</span> = <span class="literal">null</span>; <span class="comment">// fiber 上的更新队列执行一次 setState 就会往这个属性上挂一个新的更新, 每条更新最终会形成一个链表结构，最后做批量更新</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">memoizedState</span> = <span class="literal">null</span>; <span class="comment">// 对应  memoizedProps，上次渲染的 state，相当于当前的 state，理解成 prev 和 next 的关系</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">mode</span> = mode; <span class="comment">// 表示当前组件下的子组件的渲染方式</span></span><br><span class="line">    <span class="comment">// effects</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">effectTag</span> = <span class="title class_">NoEffect</span>; <span class="comment">// 表示当前 fiber 要进行何种更新（更新、删除等）</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">nextEffect</span> = <span class="literal">null</span>; <span class="comment">// 指向下个需要更新的fiber</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">firstEffect</span> = <span class="literal">null</span>; <span class="comment">// 指向所有子节点里，需要更新的 fiber 里的第一个</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lastEffect</span> = <span class="literal">null</span>; <span class="comment">// 指向所有子节点中需要更新的 fiber 的最后一个</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">expirationTime</span> = <span class="title class_">NoWork</span>; <span class="comment">// 过期时间，代表任务在未来的哪个时间点应该被完成</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">childExpirationTime</span> = <span class="title class_">NoWork</span>; <span class="comment">// child 过期时间</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">alternate</span> = <span class="literal">null</span>; <span class="comment">// current 树和 workInprogress 树之间的相互引用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/22131908/157622436-bb9c2801-e5e6-4086-82e3-828a96128fe1.png" alt="image"></p>
<blockquote>
<p>简单模拟生成以及遍历整个fiber 树过程</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化的fiber 节点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FiberNode</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">child</span> = <span class="literal">null</span>; <span class="comment">// 子节点</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">return</span> = <span class="literal">null</span>; <span class="comment">// 父节点</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sibling</span> = <span class="literal">null</span>; <span class="comment">// 兄弟节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟的dom树结构</span></span><br><span class="line"><span class="keyword">const</span> domTree = [&#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;div#A&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [&#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;text(A1)&#x27;</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;div#B1&#x27;</span>,</span><br><span class="line">        <span class="attr">children</span>: [&#123;</span><br><span class="line">            <span class="attr">value</span>: <span class="string">&#x27;text(B1)&#x27;</span></span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            <span class="attr">value</span>: <span class="string">&#x27;div#C1&#x27;</span>,</span><br><span class="line">            <span class="attr">children</span>: [&#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="string">&#x27;text(C1)&#x27;</span></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            <span class="attr">value</span>: <span class="string">&#x27;div#C2&#x27;</span>,</span><br><span class="line">            <span class="attr">children</span>: [&#123;</span><br><span class="line">                <span class="attr">value</span>: <span class="string">&#x27;text(C2)&#x27;</span></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;div#B2&#x27;</span>,</span><br><span class="line">        <span class="attr">children</span>: [&#123;</span><br><span class="line">            <span class="attr">value</span>: <span class="string">&#x27;text(B2)&#x27;</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成fiber树</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateFiberTree</span>(<span class="params">domTree</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> headerNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> curNode = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    domTree.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="title class_">FiberNode</span>(item.<span class="property">value</span>);</span><br><span class="line">        <span class="keyword">if</span>(!headerNode) &#123;</span><br><span class="line">            headerNode = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curNode.<span class="property">sibling</span> = node;</span><br><span class="line">            curNode = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="title function_">performChildren</span> = (<span class="params">returnNode, children</span>) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> curChildNode = <span class="literal">null</span></span><br><span class="line">            children.<span class="title function_">forEach</span>(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> childNode = <span class="keyword">new</span> <span class="title class_">FiberNode</span>(child.<span class="property">value</span>);</span><br><span class="line">                childNode.<span class="property">return</span> = returnNode;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (!curChildNode) &#123;</span><br><span class="line">                    returnNode.<span class="property">child</span> = childNode</span><br><span class="line">                    curChildNode = childNode;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    curChildNode.<span class="property">sibling</span> = childNode;</span><br><span class="line">                    curChildNode = childNode;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(child.<span class="property">children</span>) <span class="title function_">performChildren</span>(childNode, child.<span class="property">children</span>);</span><br><span class="line">            &#125;) </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(item.<span class="property">children</span>) <span class="title function_">performChildren</span>(node, item.<span class="property">children</span>);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> headerNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fiberTree = <span class="title function_">generateFiberTree</span>(domTree);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次遍历节点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">performUnitWork</span>(<span class="params">currentFiber</span>) &#123;</span><br><span class="line">    <span class="comment">// 有儿子就返回儿子</span></span><br><span class="line">    <span class="keyword">if</span> (currentFiber.<span class="property">child</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> currentFiber.<span class="property">child</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有儿子，则找弟弟</span></span><br><span class="line">    <span class="keyword">while</span>(currentFiber) &#123;</span><br><span class="line">        <span class="comment">// completeUnitWork(currentFiber);//将自己的副作用挂到父节点去</span></span><br><span class="line">        <span class="keyword">if</span>(currentFiber.<span class="property">sibling</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> currentFiber.<span class="property">sibling</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有弟弟就返回父节点</span></span><br><span class="line">            currentFiber = currentFiber.<span class="property">return</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 保存当前的fiber节点，下次终端可继续执行</span></span><br><span class="line"><span class="keyword">let</span> node = fiberTree</span><br><span class="line"><span class="comment">// 当前是是否有足够时间执行，这里为了方便，直接遍历</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">value</span>)</span><br><span class="line">    node = <span class="title function_">performUnitWork</span>(node)</span><br><span class="line">    <span class="keyword">if</span>(!node) <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行结果对比</p>
</blockquote>
<p><img src="https://user-images.githubusercontent.com/22131908/157636984-c4d8c93c-b92f-4c39-a232-a43bc09e11ca.png" alt="image"></p>
<blockquote>
<p>分析 </p>
</blockquote>
<p><img src="https://user-images.githubusercontent.com/22131908/157636890-18bf3b72-ab12-4380-b999-b40f43e2c750.png" alt="未命名绘图 drawio"></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/react/" rel="tag"># react</a>
          
            <a href="/tags/fiber/" rel="tag"># fiber</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/08/09/react-hooks%E4%B8%8Eclass%E7%BB%84%E4%BB%B6%E5%AF%B9%E6%AF%94/" rel="next" title="react hooks与class组件对比">
                <i class="fa fa-chevron-left"></i> react hooks与class组件对比
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/09/10/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B/" rel="prev" title="发布订阅模型">
                发布订阅模型 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/rhwoodpecker" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:rhwoodpecker@163.com" target="_blank" title="E-Mail">
                  
                    <i class="fa fa-fw fa-envelope"></i>
                  
                    
                      E-Mail
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81Fiber-%E6%9E%B6%E6%9E%84%E8%AF%9E%E7%94%9F"><span class="nav-number">1.</span> <span class="nav-text">一、Fiber 架构诞生</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#React-%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="nav-number">1.1.</span> <span class="nav-text">React 渲染页面的两个阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#React-15-%E6%9E%B6%E6%9E%84"><span class="nav-number">1.2.</span> <span class="nav-text">React 15 架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#React-16-%E6%9E%B6%E6%9E%84"><span class="nav-number">1.3.</span> <span class="nav-text">React 16 架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#React-17-%E4%BC%98%E5%8C%96"><span class="nav-number">1.4.</span> <span class="nav-text">React 17 优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81Fiber-%E6%9E%B6%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">二、Fiber 架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#React-Fiber-%E6%97%B6%E9%97%B4%E5%88%86%E7%89%87"><span class="nav-number">2.1.</span> <span class="nav-text">React Fiber 时间分片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#React-15-%E7%9A%84-Stack-Reconciler"><span class="nav-number">2.2.</span> <span class="nav-text">React 15 的 Stack Reconciler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#React-16-%E7%9A%84-Fiber-Reconciler"><span class="nav-number">2.3.</span> <span class="nav-text">React 16 的 Fiber Reconciler</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81React-Fiber-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B%E5%8F%AF%E6%8E%A7"><span class="nav-number">3.</span> <span class="nav-text">三、React Fiber 如何实现更新过程可控</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E6%8B%86%E5%88%86"><span class="nav-number">3.1.</span> <span class="nav-text">任务拆分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E6%8C%82%E8%B5%B7%E3%80%81%E6%81%A2%E5%A4%8D%E3%80%81%E7%BB%88%E6%AD%A2"><span class="nav-number">3.2.</span> <span class="nav-text">任务挂起、恢复、终止</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%82%E8%B5%B7"><span class="nav-number">3.2.1.</span> <span class="nav-text">挂起</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%81%A2%E5%A4%8D"><span class="nav-number">3.2.2.</span> <span class="nav-text">恢复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%88%E6%AD%A2"><span class="nav-number">3.2.3.</span> <span class="nav-text">终止</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%85%B7%E5%A4%87%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">3.3.</span> <span class="nav-text">任务具备优先级</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81Fiber%E7%BB%93%E6%9E%84%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7"><span class="nav-number">4.</span> <span class="nav-text">四、Fiber结构长什么样</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ren Hao</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
