(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{601:function(e,v,_){"use strict";_.r(v);var c=_(17),r=Object(c.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#结构"}},[e._v("#")]),e._v(" 结构")]),e._v(" "),_("h2",{attrs:{id:"react15的架构可以分为两层"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#react15的架构可以分为两层"}},[e._v("#")]),e._v(" react15的架构可以分为两层：")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("Reconciler")]),e._v("（协调器）— 找出需要更新的组件，以及标识出如何更新")]),e._v(" "),_("li",[_("code",[e._v("Renderer")]),e._v("（渲染器）— 负责将变化后的组件渲染到页面上")])]),e._v(" "),_("h2",{attrs:{id:"react16的架构可以分为三层"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#react16的架构可以分为三层"}},[e._v("#")]),e._v(" react16的架构可以分为三层：")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("Scheduler")]),e._v("（调度器）— 调度任务的优先级，高级优先级的优先进入 "),_("code",[e._v("Reconciler")]),e._v(" 阶段")]),e._v(" "),_("li",[_("code",[e._v("Reconciler")]),e._v("（协调器）— 找出需要更新的组件，以及标识出如何更新")]),e._v(" "),_("li",[_("code",[e._v("Renderer")]),e._v("（渲染器）— 负责将变化后的组件渲染到页面上")])]),e._v(" "),_("p",[e._v("浏览器的"),_("code",[e._v("16.6ms")]),e._v("机制")]),e._v(" "),_("p",[e._v("对人眼来说，正常流畅的刷新率为"),_("code",[e._v("60hz")]),e._v("，即 "),_("code",[e._v("60帧")]),e._v("，即浏览器"),_("code",[e._v("16.6ms")]),e._v("刷新一次。")]),e._v(" "),_("p",[e._v("我们知道js可以操作 "),_("code",[e._v("dom")]),e._v(" 元素，所以浏览器的 "),_("code",[e._v("GUI")]),e._v(" 线程和 "),_("code",[e._v("js")]),e._v(" 线程是互斥的。"),_("code",[e._v("js")]),e._v(" 的执行和浏览器的绘制、布局不能同时进行。所以在每 "),_("code",[e._v("16.6ms")]),e._v(" 内浏览器要执行如下操作：")]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("JS脚本执行 ------ 浏览器样式布局 ------ 浏览器样式绘制\n")])])]),_("p",[e._v("如果js脚本执行时间过长，超过16.6ms，这次刷新中浏览器绘制和布局就无法执行，这就会造成人眼可识别的卡顿，发现操作时浏览器没有“实时”做出反应。如：对于用户在输入框输入内容这个行为来说，就体现为按下了键盘按键但是页面上不实时显示输入。")]),e._v(" "),_("h2",{attrs:{id:"区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[e._v("#")]),e._v(" 区别")]),e._v(" "),_("h3",{attrs:{id:"react-15"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#react-15"}},[e._v("#")]),e._v(" react 15")]),e._v(" "),_("p",[_("strong",[e._v("react15")]),e._v(" 的 "),_("code",[e._v("reconciler")]),e._v(" 是 "),_("code",[e._v("stack-reconciler")]),e._v("。")]),e._v(" "),_("p",[e._v("即是采用递归形式工作的，是同步的，在生成虚拟 "),_("code",[e._v("dom")]),e._v(" 树并 "),_("code",[e._v("diff")]),e._v(" 过程中是无法中断的。")]),e._v(" "),_("p",[e._v("这样在组件层级过深时，会造成js执行时间过长，浏览器无法布局和绘制，造成丢帧。")]),e._v(" "),_("h3",{attrs:{id:"react-16"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#react-16"}},[e._v("#")]),e._v(" react 16")]),e._v(" "),_("p",[_("strong",[e._v("react16")]),e._v("的 "),_("code",[e._v("reconciler")]),e._v(" 是 "),_("code",[e._v("fiber-reconciler")]),e._v("。")]),e._v(" "),_("p",[e._v("即采用的异步可中断更新代替react15的同步更新，react16的 "),_("code",[e._v("scheduler")]),e._v(" 调度器会告诉 "),_("code",[e._v("reconciler")]),e._v(" ，浏览器是否有空闲时间执行js脚本。")]),e._v(" "),_("p",[e._v("这样就不会影响浏览器的绘制和布局工作。不会丢帧。\n在react16中，原来的虚拟 "),_("code",[e._v("DOM")]),e._v(",因其结构已不能满足异步可中断更新的需求，改而采用新的结构 "),_("code",[e._v("Fiber")]),e._v("。")]),e._v(" "),_("p",[_("code",[e._v("虚拟dom")]),e._v(" 节对应变为 "),_("code",[e._v("Fiber 节点")]),e._v("，虚拟dom树对应变为 "),_("code",[e._v("Fiber树")]),e._v("。")])])}),[],!1,null,null,null);v.default=r.exports}}]);